<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pie Guard - Protect Your Pie!</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            touch-action: none;
        }

        #gameContainer {
            position: relative;
            text-align: center;
        }

        canvas {
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F6FF 100%);
            border: 4px solid #333;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            cursor: crosshair;
            touch-action: none;
            max-width: 100%;
            max-height: 100%;
        }

        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            padding: 10px 20px;
            text-decoration: none;
            border-radius: 8px;
            font-weight: bold;
            transition: all 0.3s;
            z-index: 10;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }

        .back-button:hover {
            background: white;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.3);
        }

        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 25px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            z-index: 10;
        }

        #stats div {
            font-size: 16px;
            font-weight: bold;
            color: #333;
            margin: 5px 0;
        }

        #score {
            color: #4CAF50;
            font-size: 28px;
        }

        #wave {
            color: #FF9800;
            font-size: 20px;
        }

        #kills {
            color: #9C27B0;
            font-size: 16px;
        }

        #remaining {
            color: #FF5722;
            font-size: 16px;
        }

        #health {
            color: #F44336;
        }
    </style>
</head>
<body>
    <a href="/" class="back-button">üè† Home</a>
    
    <div id="stats">
        <div>Score: <span id="score">0</span></div>
        <div id="wave">Wave: 1/3</div>
        <div id="kills">Killed: <span>0</span></div>
        <div id="remaining">Remaining: <span>0</span></div>
        <div id="health">Lives: ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
    </div>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");

        // Responsive canvas setup
        const BASE_WIDTH = 800;
        const BASE_HEIGHT = 600;
        const ASPECT_RATIO = BASE_WIDTH / BASE_HEIGHT;
        let CANVAS_WIDTH = BASE_WIDTH;
        let CANVAS_HEIGHT = BASE_HEIGHT;
        let scale = 1;

        function resizeCanvas() {
            const maxWidth = window.innerWidth - 40;
            const maxHeight = window.innerHeight - 180;
            
            let width = Math.min(BASE_WIDTH, maxWidth);
            let height = width / ASPECT_RATIO;
            
            if (height > maxHeight) {
                height = maxHeight;
                width = height * ASPECT_RATIO;
            }
            
            canvas.width = BASE_WIDTH;
            canvas.height = BASE_HEIGHT;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            
            CANVAS_WIDTH = BASE_WIDTH;
            CANVAS_HEIGHT = BASE_HEIGHT;
            scale = width / BASE_WIDTH;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeCanvas, 100);
        });

        const scoreDisplay = document.getElementById("score");
        const waveDisplay = document.getElementById("wave");
        const healthDisplay = document.getElementById("health");
        const killsDisplay = document.querySelector("#kills span");
        const remainingDisplay = document.querySelector("#remaining span");

        class Pie {
            constructor() {
                this.x = CANVAS_WIDTH / 2;
                this.y = CANVAS_HEIGHT / 2;
                this.radius = 50;
                this.steamParticles = [];
                
                // Create steam particles
                for (let i = 0; i < 8; i++) {
                    this.steamParticles.push({
                        angle: (Math.PI * 2 * i) / 8,
                        offset: 0,
                        opacity: Math.random()
                    });
                }
            }

            update() {
                // Animate steam
                this.steamParticles.forEach(particle => {
                    particle.offset += 0.5;
                    if (particle.offset > 40) {
                        particle.offset = 0;
                        particle.opacity = Math.random();
                    }
                });
            }

            draw() {
                // Draw shadow
                ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
                ctx.beginPath();
                ctx.ellipse(this.x, this.y + 5, this.radius + 5, this.radius / 3, 0, 0, Math.PI * 2);
                ctx.fill();

                // Draw pie dish
                ctx.fillStyle = "#8B4513";
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Draw pie crust
                ctx.fillStyle = "#D2691E";
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius - 5, 0, Math.PI * 2);
                ctx.fill();

                // Draw lattice pattern
                ctx.strokeStyle = "#8B4513";
                ctx.lineWidth = 3;
                for (let i = -1; i <= 1; i++) {
                    ctx.beginPath();
                    ctx.moveTo(this.x + i * 20 - 30, this.y - 30);
                    ctx.lineTo(this.x + i * 20 + 30, this.y + 30);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(this.x + i * 20 - 30, this.y + 30);
                    ctx.lineTo(this.x + i * 20 + 30, this.y - 30);
                    ctx.stroke();
                }

                // Draw steam
                this.steamParticles.forEach(particle => {
                    const x = this.x + Math.cos(particle.angle) * 20;
                    const y = this.y - this.radius - particle.offset;
                    
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.6 * (1 - particle.offset / 40) * particle.opacity})`;
                    ctx.beginPath();
                    ctx.arc(x, y, 5 + particle.offset / 4, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
        }

        class Fly {
            constructor(wave) {
                this.wave = wave;
                this.type = "fly";
                this.spawnFromEdge();
                this.speed = 0.25; // Reduced to 1/4 speed
                this.size = 8;
                this.alive = true;
                this.targetX = CANVAS_WIDTH / 2;
                this.targetY = CANVAS_HEIGHT / 2;
                this.wingAngle = 0;
                this.erraticTimer = 0;
                this.erraticX = 0;
                this.erraticY = 0;
                this.buzzTimer = Math.random() * Math.PI * 2;
            }

            spawnFromEdge() {
                const edge = Math.floor(Math.random() * 4);
                switch(edge) {
                    case 0: // Top
                        this.x = Math.random() * CANVAS_WIDTH;
                        this.y = -20;
                        break;
                    case 1: // Right
                        this.x = CANVAS_WIDTH + 20;
                        this.y = Math.random() * CANVAS_HEIGHT;
                        break;
                    case 2: // Bottom
                        this.x = Math.random() * CANVAS_WIDTH;
                        this.y = CANVAS_HEIGHT + 20;
                        break;
                    case 3: // Left
                        this.x = -20;
                        this.y = Math.random() * CANVAS_HEIGHT;
                        break;
                }
            }

            update(pie) {
                if (!this.alive) return;

                // Wing animation
                this.wingAngle += 0.5;

                // Buzz movement (small rapid movements)
                this.buzzTimer += 0.2;

                // Erratic movement - change direction randomly
                this.erraticTimer++;
                if (this.erraticTimer > 30 + Math.random() * 40) {
                    this.erraticTimer = 0;
                    this.erraticX = (Math.random() - 0.5) * 100;
                    this.erraticY = (Math.random() - 0.5) * 100;
                }

                // Calculate direction to pie with erratic offset
                const targetX = pie.x + this.erraticX;
                const targetY = pie.y + this.erraticY;
                
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Move toward target with buzz
                if (distance > 5) {
                    this.x += (dx / distance) * this.speed + Math.cos(this.buzzTimer) * 1.5;
                    this.y += (dy / distance) * this.speed + Math.sin(this.buzzTimer) * 1.5;
                }

                // Occasional sudden direction change
                if (Math.random() < 0.02) {
                    this.x += (Math.random() - 0.5) * 30;
                    this.y += (Math.random() - 0.5) * 30;
                }
            }

            draw() {
                if (!this.alive) return;

                ctx.save();
                ctx.translate(this.x, this.y);

                // Draw shadow
                ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
                ctx.beginPath();
                ctx.ellipse(2, 3, this.size * 0.8, this.size * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();

                // Draw wings
                const wingOffset = Math.sin(this.wingAngle) * 0.5;
                ctx.fillStyle = "rgba(200, 230, 255, 0.7)";
                
                // Left wing
                ctx.beginPath();
                ctx.ellipse(-this.size * 0.7, -wingOffset * 3, this.size * 0.8, this.size * 0.5, -Math.PI / 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Right wing
                ctx.beginPath();
                ctx.ellipse(this.size * 0.7, -wingOffset * 3, this.size * 0.8, this.size * 0.5, Math.PI / 4, 0, Math.PI * 2);
                ctx.fill();

                // Draw body
                ctx.fillStyle = "#222";
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size * 0.6, this.size, 0, 0, Math.PI * 2);
                ctx.fill();

                // Draw stripes
                ctx.strokeStyle = "#555";
                ctx.lineWidth = 2;
                for (let i = -1; i <= 1; i++) {
                    ctx.beginPath();
                    ctx.moveTo(-this.size * 0.5, i * 4);
                    ctx.lineTo(this.size * 0.5, i * 4);
                    ctx.stroke();
                }

                // Draw eyes
                ctx.fillStyle = "red";
                ctx.beginPath();
                ctx.arc(-2, -this.size * 0.5, 2, 0, Math.PI * 2);
                ctx.arc(2, -this.size * 0.5, 2, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            checkClick(mouseX, mouseY) {
                const dx = mouseX - this.x;
                const dy = mouseY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < this.size * 2; // Hit box slightly larger than visual
            }

            checkPieCollision(pie) {
                const dx = this.x - pie.x;
                const dy = this.y - pie.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < pie.radius + this.size;
            }

            die() {
                this.alive = false;
            }
        }

        class Mosquito {
            constructor(wave) {
                this.wave = wave;
                this.type = "mosquito";
                this.spawnFromEdge();
                this.speed = 0.25; // Reduced to 1/4 speed
                this.size = 6; // Smaller = harder to hit
                this.alive = true;
                this.targetX = CANVAS_WIDTH / 2;
                this.targetY = CANVAS_HEIGHT / 2;
                this.wingAngle = 0;
                this.erraticTimer = 0;
                this.erraticX = 0;
                this.erraticY = 0;
                this.buzzTimer = Math.random() * Math.PI * 2;
                this.zigzagTimer = 0;
            }

            spawnFromEdge() {
                const edge = Math.floor(Math.random() * 4);
                switch(edge) {
                    case 0: this.x = Math.random() * CANVAS_WIDTH; this.y = -20; break;
                    case 1: this.x = CANVAS_WIDTH + 20; this.y = Math.random() * CANVAS_HEIGHT; break;
                    case 2: this.x = Math.random() * CANVAS_WIDTH; this.y = CANVAS_HEIGHT + 20; break;
                    case 3: this.x = -20; this.y = Math.random() * CANVAS_HEIGHT; break;
                }
            }

            update(pie) {
                if (!this.alive) return;

                this.wingAngle += 0.7; // Faster wing flap
                this.buzzTimer += 0.3;
                this.zigzagTimer += 0.15;

                // MUCH more erratic changes - bigger range, more frequent!
                this.erraticTimer++;
                if (this.erraticTimer > 12 + Math.random() * 20) { // More frequent changes
                    this.erraticTimer = 0;
                    this.erraticX = (Math.random() - 0.5) * 200; // Bigger random offset
                    this.erraticY = (Math.random() - 0.5) * 200;
                }

                const targetX = pie.x + this.erraticX;
                const targetY = pie.y + this.erraticY;
                
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Bigger zigzag movement
                const zigzagX = Math.sin(this.zigzagTimer) * 4;
                const zigzagY = Math.cos(this.zigzagTimer) * 4;

                if (distance > 5) {
                    this.x += (dx / distance) * this.speed + Math.cos(this.buzzTimer) * 2.5 + zigzagX;
                    this.y += (dy / distance) * this.speed + Math.sin(this.buzzTimer) * 2.5 + zigzagY;
                }

                // More frequent and BIGGER sudden jumps
                if (Math.random() < 0.05) { // 5% chance (was 4%)
                    this.x += (Math.random() - 0.5) * 60; // Bigger jumps
                    this.y += (Math.random() - 0.5) * 60;
                }
            }

            draw() {
                if (!this.alive) return;

                ctx.save();
                ctx.translate(this.x, this.y);

                // Smaller shadow
                ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
                ctx.beginPath();
                ctx.ellipse(1, 2, this.size * 0.6, this.size * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();

                // Thin wings
                const wingOffset = Math.sin(this.wingAngle) * 0.6;
                ctx.fillStyle = "rgba(200, 230, 255, 0.6)";
                ctx.beginPath();
                ctx.ellipse(-this.size * 0.6, -wingOffset * 2, this.size * 0.6, this.size * 0.4, -Math.PI / 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(this.size * 0.6, -wingOffset * 2, this.size * 0.6, this.size * 0.4, Math.PI / 4, 0, Math.PI * 2);
                ctx.fill();

                // Thin body
                ctx.fillStyle = "#444";
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size * 0.4, this.size * 1.2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Proboscis (needle)
                ctx.strokeStyle = "#222";
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, -this.size * 1.2);
                ctx.lineTo(0, -this.size * 2);
                ctx.stroke();

                // Eyes
                ctx.fillStyle = "red";
                ctx.beginPath();
                ctx.arc(-1, -this.size * 0.8, 1.5, 0, Math.PI * 2);
                ctx.arc(1, -this.size * 0.8, 1.5, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            checkClick(mouseX, mouseY) {
                const dx = mouseX - this.x;
                const dy = mouseY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < this.size * 2.5; // Slightly larger hit box
            }

            checkPieCollision(pie) {
                const dx = this.x - pie.x;
                const dy = this.y - pie.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < pie.radius + this.size;
            }

            die() {
                this.alive = false;
            }
        }

        class Wasp {
            constructor(wave) {
                this.wave = wave;
                this.type = "wasp";
                this.spawnFromEdge();
                this.speed = 0.25; // Reduced to 1/4 speed
                this.size = 10;
                this.alive = true;
                this.targetX = CANVAS_WIDTH / 2;
                this.targetY = CANVAS_HEIGHT / 2;
                this.wingAngle = 0;
                this.erraticTimer = 0;
                this.erraticX = 0;
                this.erraticY = 0;
                this.buzzTimer = Math.random() * Math.PI * 2;
                this.aggressiveTimer = 0;
                this.dashSpeed = 0;
            }

            spawnFromEdge() {
                const edge = Math.floor(Math.random() * 4);
                switch(edge) {
                    case 0: this.x = Math.random() * CANVAS_WIDTH; this.y = -20; break;
                    case 1: this.x = CANVAS_WIDTH + 20; this.y = Math.random() * CANVAS_HEIGHT; break;
                    case 2: this.x = Math.random() * CANVAS_WIDTH; this.y = CANVAS_HEIGHT + 20; break;
                    case 3: this.x = -20; this.y = Math.random() * CANVAS_HEIGHT; break;
                }
            }

            update(pie) {
                if (!this.alive) return;

                this.wingAngle += 0.8;
                this.buzzTimer += 0.5;
                this.aggressiveTimer++;

                // Sudden aggressive dashes - more frequent, but no speed boost, just direction change
                if (this.aggressiveTimer > 40 + Math.random() * 60) { // More frequent dashes
                    this.aggressiveTimer = 0;
                    // Dash creates a sudden direction change, not speed
                    this.erraticX = (Math.random() - 0.5) * 300; // Massive offset
                    this.erraticY = (Math.random() - 0.5) * 300;
                }

                // EXTREMELY erratic movement - huge range, very frequent!
                this.erraticTimer++;
                if (this.erraticTimer > 8 + Math.random() * 15) { // Very frequent changes
                    this.erraticTimer = 0;
                    this.erraticX = (Math.random() - 0.5) * 250; // Massive random offset
                    this.erraticY = (Math.random() - 0.5) * 250;
                }

                const targetX = pie.x + this.erraticX;
                const targetY = pie.y + this.erraticY;
                
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 5) {
                    this.x += (dx / distance) * this.speed + Math.cos(this.buzzTimer) * 3.5;
                    this.y += (dy / distance) * this.speed + Math.sin(this.buzzTimer) * 3.5;
                }

                // VERY frequent and MASSIVE unpredictable jumps
                if (Math.random() < 0.08) { // 8% chance (very frequent!)
                    this.x += (Math.random() - 0.5) * 100; // Huge jumps
                    this.y += (Math.random() - 0.5) * 100;
                }
            }

            draw() {
                if (!this.alive) return;

                ctx.save();
                ctx.translate(this.x, this.y);

                // Shadow
                ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
                ctx.beginPath();
                ctx.ellipse(2, 3, this.size * 0.8, this.size * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();

                // Wings
                const wingOffset = Math.sin(this.wingAngle) * 0.7;
                ctx.fillStyle = "rgba(255, 230, 200, 0.5)";
                ctx.beginPath();
                ctx.ellipse(-this.size * 0.8, -wingOffset * 3, this.size * 0.9, this.size * 0.5, -Math.PI / 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(this.size * 0.8, -wingOffset * 3, this.size * 0.9, this.size * 0.5, Math.PI / 4, 0, Math.PI * 2);
                ctx.fill();

                // Body (yellow and black stripes)
                ctx.fillStyle = "#FFD700";
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size * 0.5, this.size, 0, 0, Math.PI * 2);
                ctx.fill();

                // Black stripes
                ctx.fillStyle = "#000";
                for (let i = -2; i <= 2; i++) {
                    ctx.fillRect(-this.size * 0.5, i * 4 - 2, this.size, 3);
                }

                // Stinger
                ctx.fillStyle = "#222";
                ctx.beginPath();
                ctx.moveTo(0, this.size);
                ctx.lineTo(-2, this.size + 5);
                ctx.lineTo(2, this.size + 5);
                ctx.closePath();
                ctx.fill();

                // Eyes
                ctx.fillStyle = "#000";
                ctx.beginPath();
                ctx.arc(-3, -this.size * 0.6, 2, 0, Math.PI * 2);
                ctx.arc(3, -this.size * 0.6, 2, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            checkClick(mouseX, mouseY) {
                const dx = mouseX - this.x;
                const dy = mouseY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < this.size * 2;
            }

            checkPieCollision(pie) {
                const dx = this.x - pie.x;
                const dy = this.y - pie.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < pie.radius + this.size;
            }

            die() {
                this.alive = false;
            }
        }

        class Game {
            constructor() {
                this.pie = new Pie();
                this.insects = []; // Changed from flies to insects
                this.insectsOnPie = []; // Insects walking on the pie
                this.score = 0;
                this.wave = 1;
                this.maxWaves = 3;
                this.maxLives = 5; // Maximum lives per wave
                this.lives = 5; // Start with 5 lives
                this.gameState = "WAVE_ANNOUNCEMENT"; // WAVE_ANNOUNCEMENT, PLAYING, GAME_OVER, WON
                this.spawnTimer = 0;
                this.insectSpawnRate = 120; // Frames between spawns
                this.maxInsects = 4; // Max insects on screen at once
                this.bloodSplatters = [];
                this.killsThisWave = 0;
                this.insectsToKillThisWave = 15; // Need to kill 15 per wave
                this.waveAnnouncementTimer = 0;
                this.waveAnnouncementDuration = 180; // 3 seconds at 60fps
                
                this.updateDisplays();
            }

            spawnInitialInsects() {
                for (let i = 0; i < Math.min(this.wave + 2, this.maxInsects); i++) {
                    this.spawnInsect();
                }
            }

            spawnInsect() {
                const aliveCount = this.insects.filter(i => i.alive).length;
                if (aliveCount >= this.maxInsects + this.wave) return;

                // Different insects per wave
                let insect;
                if (this.wave === 1) {
                    // Wave 1: Only flies
                    insect = new Fly(this.wave);
                } else if (this.wave === 2) {
                    // Wave 2: Flies + Mosquitoes
                    insect = Math.random() < 0.5 ? new Fly(this.wave) : new Mosquito(this.wave);
                } else if (this.wave === 3) {
                    // Wave 3: All three types!
                    const rand = Math.random();
                    if (rand < 0.33) {
                        insect = new Fly(this.wave);
                    } else if (rand < 0.66) {
                        insect = new Mosquito(this.wave);
                    } else {
                        insect = new Wasp(this.wave);
                    }
                }
                
                this.insects.push(insect);
            }

            update() {
                this.pie.update();

                // Handle wave announcement
                if (this.gameState === "WAVE_ANNOUNCEMENT") {
                    this.waveAnnouncementTimer++;
                    if (this.waveAnnouncementTimer >= this.waveAnnouncementDuration) {
                        this.gameState = "PLAYING";
                        this.waveAnnouncementTimer = 0;
                        this.spawnInitialInsects();
                    }
                    return;
                }

                if (this.gameState !== "PLAYING") return;

                // Update insects
                this.insects.forEach(insect => {
                    insect.update(this.pie);

                    // Check if insect reached pie
                    if (insect.alive && insect.checkPieCollision(this.pie)) {
                        this.lives--;
                        
                        // Add insect to pie walkers
                        this.insectsOnPie.push({
                            type: insect.type,
                            angle: Math.random() * Math.PI * 2,
                            speed: 0.01 + Math.random() * 0.01,
                            radius: this.pie.radius - 10 - Math.random() * 15,
                            size: insect.size,
                            wingAngle: 0
                        });
                        
                        insect.die();
                        this.addSplatter(insect.x, insect.y, "#8B4513"); // Brown splatter for pie hit
                        
                        if (this.lives <= 0) {
                            this.gameState = "GAME_OVER";
                        }
                        
                        this.updateHealthDisplay();
                        this.updateDisplays();
                    }
                });

                // Update insects on pie
                this.insectsOnPie.forEach(insect => {
                    insect.angle += insect.speed;
                    insect.wingAngle += 0.3;
                });

                // Spawn new insects
                this.spawnTimer++;
                if (this.spawnTimer > this.insectSpawnRate - this.wave * 10) {
                    this.spawnTimer = 0;
                    this.spawnInsect();
                }

                // Clean up dead insects (after a delay)
                this.insects = this.insects.filter((insect, index) => {
                    return insect.alive || index > this.insects.length - 10;
                });

                // Update blood splatters
                this.bloodSplatters = this.bloodSplatters.filter(splat => {
                    splat.life--;
                    splat.alpha = splat.life / 60;
                    return splat.life > 0;
                });

                // Check for wave completion
                if (this.killsThisWave >= this.insectsToKillThisWave) {
                    // Clear remaining insects
                    this.insects = [];
                    this.insectsOnPie = []; // Clear insects on pie for next wave
                    
                    if (this.wave >= this.maxWaves) {
                        this.gameState = "WON";
                    } else {
                        this.nextWave();
                    }
                }

                this.updateDisplays();
            }

            nextWave() {
                this.wave++;
                this.lives = this.maxLives; // Reset lives to 5 for new wave!
                this.killsThisWave = 0;
                this.insectsToKillThisWave = 15 + (this.wave - 1) * 5; // More kills needed each wave
                this.insectSpawnRate = Math.max(40, this.insectSpawnRate - 15);
                this.maxInsects += 1; // More insects on screen
                this.gameState = "WAVE_ANNOUNCEMENT";
                this.waveAnnouncementTimer = 0;
                this.updateHealthDisplay();
                this.updateDisplays();
            }

            addSplatter(x, y, color) {
                this.bloodSplatters.push({
                    x: x,
                    y: y,
                    color: color,
                    life: 60,
                    alpha: 1,
                    size: 10 + Math.random() * 10
                });
            }

            handleClick(mouseX, mouseY) {
                if (this.gameState !== "PLAYING") return;
                // GAME_OVER and WON now only restart with 'R' key

                // Check if any insect was clicked
                for (let i = this.insects.length - 1; i >= 0; i--) {
                    const insect = this.insects[i];
                    if (insect.alive && insect.checkClick(mouseX, mouseY)) {
                        insect.die();
                        this.score++;
                        this.killsThisWave++;
                        
                        // Different splatter colors for different insects
                        let color = "#8B0000"; // Dark red for flies
                        if (insect.type === "mosquito") color = "#4B0000"; // Darker for mosquitoes
                        if (insect.type === "wasp") color = "#FFD700"; // Yellow for wasps
                        
                        this.addSplatter(insect.x, insect.y, color);
                        this.updateDisplays();
                        
                        // Spawn a new insect to keep pressure
                        setTimeout(() => this.spawnInsect(), 800);
                        break; // Only kill one insect per click
                    }
                }
            }

            updateDisplays() {
                scoreDisplay.textContent = this.score;
                waveDisplay.textContent = `Wave: ${this.wave}/${this.maxWaves}`;
                killsDisplay.textContent = this.killsThisWave;
                const remaining = Math.max(0, this.insectsToKillThisWave - this.killsThisWave);
                remainingDisplay.textContent = remaining;
            }

            restart() {
                this.insects = [];
                this.insectsOnPie = [];
                this.score = 0;
                this.wave = 1;
                this.lives = this.maxLives; // Reset to 5 lives
                this.gameState = "WAVE_ANNOUNCEMENT";
                this.spawnTimer = 0;
                this.insectSpawnRate = 120;
                this.bloodSplatters = [];
                this.killsThisWave = 0;
                this.insectsToKillThisWave = 15;
                this.maxInsects = 4;
                this.waveAnnouncementTimer = 0;
                
                this.updateHealthDisplay();
                this.updateDisplays();
            }

            updateHealthDisplay() {
                const hearts = "‚ù§Ô∏è".repeat(Math.max(0, this.lives));
                const brokenHearts = "üíî".repeat(Math.max(0, this.maxLives - this.lives));
                healthDisplay.textContent = `Lives: ${hearts}${brokenHearts}`;
            }

            draw() {
                // Clear canvas
                ctx.fillStyle = "linear-gradient(to bottom, #87CEEB 0%, #E0F6FF 100%)";
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // Draw background gradient
                const gradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
                gradient.addColorStop(0, "#87CEEB");
                gradient.addColorStop(1, "#E0F6FF");
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // Draw blood splatters
                this.bloodSplatters.forEach(splat => {
                    ctx.fillStyle = `${splat.color}${Math.floor(splat.alpha * 128).toString(16).padStart(2, '0')}`;
                    ctx.beginPath();
                    ctx.arc(splat.x, splat.y, splat.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw splatter drops
                    for (let i = 0; i < 5; i++) {
                        const angle = (Math.PI * 2 * i) / 5;
                        const dropDist = splat.size * 1.5;
                        ctx.beginPath();
                        ctx.arc(
                            splat.x + Math.cos(angle) * dropDist,
                            splat.y + Math.sin(angle) * dropDist,
                            splat.size * 0.3,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    }
                });

                // Draw pie
                this.pie.draw();

                // Draw insects on pie (walking around)
                this.insectsOnPie.forEach(pieInsect => {
                    const x = this.pie.x + Math.cos(pieInsect.angle) * pieInsect.radius;
                    const y = this.pie.y + Math.sin(pieInsect.angle) * pieInsect.radius;
                    
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(pieInsect.angle + Math.PI / 2);

                    // Draw based on insect type
                    const wingOffset = Math.sin(pieInsect.wingAngle) * 0.5;
                    
                    if (pieInsect.type === "mosquito") {
                        // Mosquito on pie
                        ctx.fillStyle = "rgba(200, 230, 255, 0.6)";
                        ctx.beginPath();
                        ctx.ellipse(-pieInsect.size * 0.6, -wingOffset * 2, pieInsect.size * 0.6, pieInsect.size * 0.4, -Math.PI / 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.ellipse(pieInsect.size * 0.6, -wingOffset * 2, pieInsect.size * 0.6, pieInsect.size * 0.4, Math.PI / 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = "#444";
                        ctx.beginPath();
                        ctx.ellipse(0, 0, pieInsect.size * 0.4, pieInsect.size * 1.2, 0, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (pieInsect.type === "wasp") {
                        // Wasp on pie
                        ctx.fillStyle = "rgba(255, 230, 200, 0.5)";
                        ctx.beginPath();
                        ctx.ellipse(-pieInsect.size * 0.8, -wingOffset * 3, pieInsect.size * 0.9, pieInsect.size * 0.5, -Math.PI / 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.ellipse(pieInsect.size * 0.8, -wingOffset * 3, pieInsect.size * 0.9, pieInsect.size * 0.5, Math.PI / 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = "#FFD700";
                        ctx.beginPath();
                        ctx.ellipse(0, 0, pieInsect.size * 0.5, pieInsect.size, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = "#000";
                        for (let i = -2; i <= 2; i++) {
                            ctx.fillRect(-pieInsect.size * 0.5, i * 4 - 2, pieInsect.size, 3);
                        }
                    } else {
                        // Fly on pie
                        ctx.fillStyle = "rgba(200, 230, 255, 0.7)";
                        ctx.beginPath();
                        ctx.ellipse(-pieInsect.size * 0.7, -wingOffset * 3, pieInsect.size * 0.8, pieInsect.size * 0.5, -Math.PI / 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.ellipse(pieInsect.size * 0.7, -wingOffset * 3, pieInsect.size * 0.8, pieInsect.size * 0.5, Math.PI / 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = "#222";
                        ctx.beginPath();
                        ctx.ellipse(0, 0, pieInsect.size * 0.6, pieInsect.size, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                });

                // Draw insects
                this.insects.forEach(insect => insect.draw());

                // Draw game state text
                if (this.gameState === "WAVE_ANNOUNCEMENT") {
                    // Semi-transparent overlay
                    ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                    // Wave title
                    ctx.fillStyle = "#FFD700";
                    ctx.font = "bold 60px Arial";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(`Wave ${this.wave}`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 120);

                    // Incoming insects
                    ctx.fillStyle = "white";
                    ctx.font = "30px Arial";
                    ctx.fillText("Incoming Insects:", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 50);

                    // Show insect types
                    let yPos = CANVAS_HEIGHT / 2 + 10;
                    if (this.wave === 1) {
                        ctx.font = "28px Arial";
                        ctx.fillStyle = "#4CAF50";
                        ctx.fillText("ü™∞ Flies", CANVAS_WIDTH / 2, yPos);
                        ctx.font = "18px Arial";
                        ctx.fillStyle = "#AAA";
                        ctx.fillText("Basic movement, predictable patterns", CANVAS_WIDTH / 2, yPos + 30);
                    } else if (this.wave === 2) {
                        ctx.font = "24px Arial";
                        ctx.fillStyle = "#4CAF50";
                        ctx.fillText("ü™∞ Flies + ü¶ü Mosquitoes", CANVAS_WIDTH / 2, yPos);
                        ctx.font = "18px Arial";
                        ctx.fillStyle = "#AAA";
                        ctx.fillText("Mosquitoes zigzag wildly - much harder to predict!", CANVAS_WIDTH / 2, yPos + 30);
                    } else if (this.wave === 3) {
                        ctx.font = "22px Arial";
                        ctx.fillStyle = "#4CAF50";
                        ctx.fillText("ü™∞ Flies + ü¶ü Mosquitoes + üêù Wasps", CANVAS_WIDTH / 2, yPos);
                        ctx.font = "18px Arial";
                        ctx.fillStyle = "#AAA";
                        ctx.fillText("Wasps are CHAOS - massive unpredictable movements!", CANVAS_WIDTH / 2, yPos + 30);
                    }

                    // Target info
                    ctx.fillStyle = "#FF9800";
                    ctx.font = "24px Arial";
                    ctx.fillText(`Kill ${this.insectsToKillThisWave} insects to advance`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 100);
                    
                    // Lives reset info (only show for wave 2+)
                    if (this.wave > 1) {
                        ctx.fillStyle = "#4CAF50";
                        ctx.font = "20px Arial";
                        ctx.fillText("‚ù§Ô∏è Lives restored to 5! ‚ù§Ô∏è", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 130);
                    }

                    // Progress bar
                    const barWidth = 300;
                    const barHeight = 20;
                    const barX = CANVAS_WIDTH / 2 - barWidth / 2;
                    const barY = CANVAS_HEIGHT / 2 + 140;
                    const progress = this.waveAnnouncementTimer / this.waveAnnouncementDuration;
                    
                    ctx.fillStyle = "#444";
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    ctx.fillStyle = "#4CAF50";
                    ctx.fillRect(barX, barY, barWidth * progress, barHeight);
                    
                    ctx.strokeStyle = "white";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(barX, barY, barWidth, barHeight);

                    ctx.fillStyle = "#AAA";
                    ctx.font = "16px Arial";
                    ctx.fillText("Get ready...", CANVAS_WIDTH / 2, barY + 40);
                } else if (this.gameState === "WON") {
                    // Darken screen
                    ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                    // Victory text
                    ctx.fillStyle = "#FFD700";
                    ctx.font = "bold 60px Arial";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText("VICTORY!", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 80);

                    ctx.fillStyle = "white";
                    ctx.font = "30px Arial";
                    ctx.fillText("You protected grandma's pie!", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 20);

                    ctx.font = "40px Arial";
                    ctx.fillStyle = "#4CAF50";
                    ctx.fillText(`Final Score: ${this.score}`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 40);

                    ctx.fillStyle = "#AAA";
                    ctx.font = "20px Arial";
                    ctx.fillText("Press R to play again", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 100);
                } else if (this.gameState === "GAME_OVER") {
                    // Darken screen
                    ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                    // Game over text
                    ctx.fillStyle = "#FF4444";
                    ctx.font = "bold 60px Arial";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText("GAME OVER!", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 80);

                    ctx.fillStyle = "white";
                    ctx.font = "30px Arial";
                    ctx.fillText("The flies got your pie!", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 20);

                    ctx.font = "40px Arial";
                    ctx.fillStyle = "#FFD700";
                    ctx.fillText(`Final Score: ${this.score}`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 40);

                    ctx.fillStyle = "#AAA";
                    ctx.font = "20px Arial";
                    ctx.fillText("Press R to try again", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 100);
                }
            }
        }

        // Initialize game
        const game = new Game();

        // Game loop
        function gameLoop() {
            game.update();
            game.draw();
            requestAnimationFrame(gameLoop);
        }

        // Unified input handler for mouse and touch
        function getInputPosition(event) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;
            
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else if (event.changedTouches && event.changedTouches.length > 0) {
                clientX = event.changedTouches[0].clientX;
                clientY = event.changedTouches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }
            
            const x = (clientX - rect.left) / scale;
            const y = (clientY - rect.top) / scale;
            return { x, y };
        }

        // Event handlers
        canvas.addEventListener("click", (event) => {
            const pos = getInputPosition(event);
            game.handleClick(pos.x, pos.y);
        });

        canvas.addEventListener("touchstart", (event) => {
            event.preventDefault();
            const pos = getInputPosition(event);
            game.handleClick(pos.x, pos.y);
        }, { passive: false });

        document.addEventListener("keydown", (event) => {
            if ((event.key === "r" || event.key === "R") && (game.gameState === "GAME_OVER" || game.gameState === "WON")) {
                game.restart();
            }
        });

        // Prevent context menu
        canvas.addEventListener("contextmenu", (e) => e.preventDefault());

        // Start game loop
        gameLoop();
    </script>
</body>
</html>
