<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>The Last Step - Game Arcade</title>
    <link rel="stylesheet" href="/static/css/main.css">
    <style>
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            max-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            margin: 0;
            padding: 5px;
            overflow: hidden;
            touch-action: none;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 600px;
            padding: 8px 15px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            margin-bottom: 5px;
            flex-shrink: 0;
        }
        
        .header-btn {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            text-decoration: none;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .header-btn:hover {
            background: white;
            transform: translateY(-2px);
        }
        
        .game-title {
            color: white;
            font-size: 18px;
            margin: 0;
            text-align: center;
            flex: 1;
        }
        
        #game-container {
            position: relative;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            width: 100%;
            max-width: 600px;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 0;
        }
        
        #gameCanvas {
            display: block;
            background: #2c3e50;
            touch-action: none;
            width: 100%;
            height: auto;
        }
        
        #progress-bar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            pointer-events: none;
            z-index: 10;
        }
        
        #progress-bg {
            width: 100%;
            height: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid white;
            border-radius: 15px;
            overflow: hidden;
        }
        
        #progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A, #CDDC39, #FFC107, #FF5722);
            width: 0%;
            transition: width 0.3s;
        }
        
        #progress-text {
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            overflow-y: auto;
        }
        
        .modal-content {
            background: white;
            margin: 5% auto;
            padding: 20px;
            border-radius: 10px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }
        
        .close-modal {
            position: absolute;
            right: 15px;
            top: 15px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: #333;
        }
        
        .close-modal:hover {
            color: #000;
        }
        
        .modal-body {
            margin-top: 20px;
        }
        
        .modal-body h3 {
            color: #333;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        .modal-body p {
            color: #666;
            line-height: 1.6;
            margin: 8px 0;
        }
        
        .modal-body .warning {
            color: #FF6B6B;
            font-weight: bold;
        }

        @media (max-width: 600px) {
            .game-header {
                padding: 8px 12px;
            }
            
            .game-title {
                font-size: 16px;
            }
            
            .header-btn {
                padding: 6px 12px;
                font-size: 12px;
            }
        }

        /* Mobile Side Buttons */
        .side-button {
            display: none;
            position: absolute;
            top: 0;
            bottom: 0;
            width: 80px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            z-index: 5;
            touch-action: none;
            cursor: pointer;
            transition: background 0.15s;
        }

        @media (max-width: 768px), (max-height: 600px), (pointer: coarse) {
            .side-button {
                display: block;
            }
        }

        .side-button:active {
            background: rgba(76, 175, 80, 0.3);
        }

        .side-button.pressed {
            background: rgba(76, 175, 80, 0.4);
            border-color: #4CAF50;
        }

        #btn-left {
            left: 0;
        }

        #btn-right {
            right: 0;
        }

        .side-button-icon {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 48px;
            color: rgba(255, 255, 255, 0.6);
            font-weight: bold;
            pointer-events: none;
        }

        #btn-left .side-button-icon {
            left: 15px;
        }

        #btn-right .side-button-icon {
            right: 15px;
        }
    </style>
</head>
<body>
    <header class="game-header">
        <a href="/" class="header-btn home-btn">‚Üê Home</a>
        <h1 class="game-title">üö™ The Last Step</h1>
        <button class="header-btn info-btn" id="infoBtn">‚ÑπÔ∏è</button>
    </header>

    <div id="game-container">
        <canvas id="gameCanvas" width="500" height="700"></canvas>
        <div id="progress-bar">
            <div id="progress-bg">
                <div id="progress-fill"></div>
            </div>
            <div id="progress-text">0%</div>
        </div>
        <!-- Mobile Side Buttons -->
        <div class="side-button" id="btn-left">
            <div class="side-button-icon">‚Üê</div>
        </div>
        <div class="side-button" id="btn-right">
            <div class="side-button-icon">‚Üí</div>
        </div>
    </div>

    <!-- Info Modal -->
    <div id="infoModal" class="modal">
        <div class="modal-content">
            <span class="close-modal">&times;</span>
            <h2>üö™ The Last Step - How to Play</h2>
            <div class="modal-body">
                <h3>Objective</h3>
                <p>Reach the <strong>GOLDEN DOOR</strong> at 100%!</p>
                <p class="warning">‚ö†Ô∏è You can SEE the end... but can you reach it?</p>
                
                <h3>Controls</h3>
                <p>‚Ä¢ <strong>Desktop:</strong> ‚Üê ‚Üí arrows to move, SPACE to jump</p>
                <p>‚Ä¢ <strong>Mobile:</strong> Tap screen to jump, use side buttons (‚Üê ‚Üí) to move</p>
                <p>‚Ä¢ <strong>Press R</strong> to restart after game over</p>
                
                <h3>‚ö†Ô∏è The Challenge</h3>
                <p>‚Ä¢ Climb platforms to reach the golden door</p>
                <p>‚Ä¢ Avoid spikes - touching them = death!</p>
                <p>‚Ä¢ Progress bar shows how close you are</p>
                <p class="warning">üíÄ The last 1% (99-100%) is HELL - wind, narrow platforms, more spikes!</p>
                
                <h3>The Last 1%</h3>
                <p>‚Ä¢ Wind pushes you around randomly</p>
                <p>‚Ä¢ Platforms get narrower</p>
                <p>‚Ä¢ More spikes appear</p>
                <p>‚Ä¢ This is where legends are made... or broken!</p>
                
                <h3>Tips</h3>
                <p>‚Ä¢ Time your jumps carefully</p>
                <p>‚Ä¢ Watch for spike patterns</p>
                <p>‚Ä¢ In the last 1%, expect the unexpected!</p>
                <p>‚Ä¢ Don't give up - persistence pays off!</p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const progressFill = document.getElementById("progress-fill");
        const progressText = document.getElementById("progress-text");

        // Responsive canvas setup
        const BASE_WIDTH = 500;
        const BASE_HEIGHT = 700;
        const ASPECT_RATIO = BASE_WIDTH / BASE_HEIGHT;
        let CANVAS_WIDTH = BASE_WIDTH;
        let CANVAS_HEIGHT = BASE_HEIGHT;
        let scale = 1;

        function resizeCanvas() {
            // Get actual header height from DOM
            const header = document.querySelector('.game-header');
            const headerHeight = header ? header.offsetHeight + 10 : 70;
            const padding = 5;
            
            // Calculate available space - use ALL available height
            const availableHeight = window.innerHeight - headerHeight - padding;
            const availableWidth = window.innerWidth - padding * 2;
            
            // Fill available space - prioritize height
            let height = availableHeight;
            let width = height * ASPECT_RATIO;
            
            // If width exceeds available space, scale down
            if (width > availableWidth) {
                width = availableWidth;
                height = width / ASPECT_RATIO;
            }
            
            // Ensure we don't exceed base dimensions
            if (width > BASE_WIDTH) {
                width = BASE_WIDTH;
                height = width / ASPECT_RATIO;
            }
            if (height > BASE_HEIGHT) {
                height = BASE_HEIGHT;
                width = height * ASPECT_RATIO;
            }
            
            canvas.width = BASE_WIDTH;
            canvas.height = BASE_HEIGHT;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            
            CANVAS_WIDTH = BASE_WIDTH;
            CANVAS_HEIGHT = BASE_HEIGHT;
            scale = width / BASE_WIDTH;
        }

        // Resize immediately on load and after DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                resizeCanvas();
            });
        } else {
            resizeCanvas();
        }
        
        // Also resize after a short delay to ensure header is rendered
        setTimeout(resizeCanvas, 100);
        
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeCanvas, 200);
        });
        const GRAVITY = 0.7;
        const JUMP_STRENGTH = -18;
        const MOVE_SPEED = 6;
        const PLAYER_SIZE = 25;
        
        // Evil: The "goal" is at 10000 units high, but last 100 units are HELL
        const GOAL_HEIGHT = 10000;
        const HELL_ZONE_START = 9900; // Last 1%

        class Player {
            constructor() {
                this.x = CANVAS_WIDTH / 2;
                this.y = CANVAS_HEIGHT - 100;
                this.vx = 0;
                this.vy = 0;
                this.size = PLAYER_SIZE;
                this.onGround = false;
                this.jumpCount = 0;
                this.maxJumps = 2; // Double jump
            }

            update(keys, platforms, wind = 0) {
                // Horizontal movement
                if (keys['ArrowLeft']) {
                    this.vx = -MOVE_SPEED;
                } else if (keys['ArrowRight']) {
                    this.vx = MOVE_SPEED;
                } else {
                    this.vx *= 0.8; // Friction
                }

                // Evil: Add wind effect in hell zone
                this.vx += wind;

                // Apply gravity
                this.vy += GRAVITY;

                // Update position
                this.x += this.vx;
                this.y += this.vy;

                // Wall collision
                if (this.x < this.size / 2) {
                    this.x = this.size / 2;
                    this.vx = 0;
                } else if (this.x > CANVAS_WIDTH - this.size / 2) {
                    this.x = CANVAS_WIDTH - this.size / 2;
                    this.vx = 0;
                }

                // Platform collision
                this.onGround = false;
                for (const platform of platforms) {
                    if (this.checkPlatformCollision(platform)) {
                        this.onGround = true;
                        this.jumpCount = 0;
                        break;
                    }
                }
            }

            checkPlatformCollision(platform) {
                if (this.vy > 0 &&
                    this.x + this.size / 2 > platform.x &&
                    this.x - this.size / 2 < platform.x + platform.width &&
                    this.y + this.size / 2 > platform.y &&
                    this.y + this.size / 2 < platform.y + 20) {
                    
                    this.y = platform.y - this.size / 2;
                    this.vy = 0;
                    return true;
                }
                return false;
            }

            jump() {
                if (this.jumpCount < this.maxJumps) {
                    this.vy = JUMP_STRENGTH;
                    this.jumpCount++;
                }
            }

            draw(cameraY) {
                const screenY = this.y - cameraY;
                
                // Draw shadow
                ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
                ctx.fillRect(this.x - this.size / 2, screenY + this.size / 2 + 5, this.size, 5);

                // Draw player
                ctx.fillStyle = "#3498db";
                ctx.fillRect(this.x - this.size / 2, screenY - this.size / 2, this.size, this.size);
                
                // Draw face
                ctx.fillStyle = "white";
                ctx.fillRect(this.x - 8, screenY - 8, 5, 5);
                ctx.fillRect(this.x + 3, screenY - 8, 5, 5);
            }

            isDead(cameraY) {
                return this.y - cameraY > CANVAS_HEIGHT + 100;
            }
        }

        class Platform {
            constructor(x, y, width, moving = false, moveRange = 0) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = 15;
                this.moving = moving;
                this.moveRange = moveRange;
                this.startX = x;
                this.moveDir = 1;
                this.moveSpeed = 1.5; // Slower = more fair
            }

            update() {
                if (this.moving) {
                    this.x += this.moveDir * this.moveSpeed;
                    if (this.x > this.startX + this.moveRange || this.x < this.startX - this.moveRange) {
                        this.moveDir *= -1;
                    }
                }
            }

            draw(cameraY) {
                const screenY = this.y - cameraY;
                if (screenY > -50 && screenY < CANVAS_HEIGHT + 50) {
                    // Draw platform
                    ctx.fillStyle = "#34495e";
                    ctx.fillRect(this.x, screenY, this.width, this.height);
                    
                    // Draw edge highlight
                    ctx.fillStyle = "#546c7c";
                    ctx.fillRect(this.x, screenY, this.width, 3);
                }
            }
        }

        class Spike {
            constructor(x, y, width) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = 20;
            }

            checkCollision(player) {
                return (player.x + player.size / 2 > this.x &&
                        player.x - player.size / 2 < this.x + this.width &&
                        player.y + player.size / 2 > this.y &&
                        player.y - player.size / 2 < this.y + this.height);
            }

            draw(cameraY) {
                const screenY = this.y - cameraY;
                if (screenY > -50 && screenY < CANVAS_HEIGHT + 50) {
                    ctx.fillStyle = "#e74c3c";
                    ctx.beginPath();
                    for (let i = 0; i < this.width; i += 20) {
                        ctx.moveTo(this.x + i, screenY + this.height);
                        ctx.lineTo(this.x + i + 10, screenY);
                        ctx.lineTo(this.x + i + 20, screenY + this.height);
                    }
                    ctx.fill();
                }
            }
        }

        class Game {
            constructor() {
                this.player = new Player();
                this.platforms = [];
                this.spikes = [];
                this.cameraY = 0;
                this.keys = {};
                this.gameState = "START"; // START, PLAYING, DEAD, WON
                this.attempts = 0;
                this.bestProgress = 0;
                this.wind = 0;
                this.windTimer = 0;
                
                this.generateLevel();
            }

            generateLevel() {
                this.platforms = [];
                this.spikes = [];
                
                // Starting platform
                this.platforms.push(new Platform(150, CANVAS_HEIGHT - 50, 200));
                
                let currentY = CANVAS_HEIGHT - 200;
                
                // Easy section (0-70%)
                for (let i = 0; i < 70; i++) {
                    currentY -= 90 + Math.random() * 40;
                    const x = 50 + Math.random() * (CANVAS_WIDTH - 180);
                    const width = 130 + Math.random() * 70;
                    this.platforms.push(new Platform(x, currentY, width));
                }
                
                // Medium section (70-90%)
                for (let i = 0; i < 20; i++) {
                    currentY -= 110 + Math.random() * 30;
                    const x = 40 + Math.random() * (CANVAS_WIDTH - 140);
                    const width = 100 + Math.random() * 50;
                    const moving = Math.random() < 0.3;
                    this.platforms.push(new Platform(x, currentY, width, moving, 40));
                    
                    // Add some spikes
                    if (Math.random() < 0.25) {
                        this.spikes.push(new Spike(x + width + 10, currentY - 20, 40));
                    }
                }
                
                // Hard section (90-95%)
                for (let i = 0; i < 10; i++) {
                    currentY -= 120 + Math.random() * 20;
                    const x = 30 + Math.random() * (CANVAS_WIDTH - 120);
                    const width = 80 + Math.random() * 40;
                    const moving = Math.random() < 0.4;
                    this.platforms.push(new Platform(x, currentY, width, moving, 60));
                    
                    // More spikes
                    if (Math.random() < 0.4) {
                        this.spikes.push(new Spike(x + width + 5, currentY - 20, 30));
                    }
                }
                
                // Very hard section (95-99%)
                for (let i = 0; i < 8; i++) {
                    currentY -= 130 + Math.random() * 20;
                    const x = 20 + Math.random() * (CANVAS_WIDTH - 100);
                    const width = 70 + Math.random() * 30;
                    const moving = Math.random() < 0.6;
                    this.platforms.push(new Platform(x, currentY, width, moving, 80));
                    
                    // Lots of spikes
                    if (Math.random() < 0.6) {
                        this.spikes.push(new Spike(x + width + 3, currentY - 20, 25));
                    }
                }
                
                // HELL ZONE (99-100%) - The last 1% - HARD but POSSIBLE
                for (let i = 0; i < 4; i++) {
                    currentY -= 140;
                    const x = 60 + Math.random() * (CANVAS_WIDTH - 140);
                    const width = 55 + Math.random() * 25; // Small but not tiny
                    this.platforms.push(new Platform(x, currentY, width, true, 80));
                    
                    // Spike walls (but with gaps)
                    if (i % 2 === 0) {
                        this.spikes.push(new Spike(0, currentY - 50, 40));
                        this.spikes.push(new Spike(CANVAS_WIDTH - 40, currentY - 50, 40));
                    }
                }
                
                // Final platform before goal (challenging but fair)
                currentY -= 150;
                this.platforms.push(new Platform(CANVAS_WIDTH / 2 - 40, currentY, 80, true, 100));
                
                // Goal platform (at 100%)
                this.goalY = currentY - 250;
                this.platforms.push(new Platform(CANVAS_WIDTH / 2 - 75, this.goalY, 150));
            }

            start() {
                this.player = new Player();
                this.cameraY = 0;
                this.gameState = "PLAYING";
                this.attempts++;
                this.wind = 0;
                this.windTimer = 0;
            }

            update() {
                if (this.gameState !== "PLAYING") return;

                // Calculate progress
                const progress = Math.max(0, (CANVAS_HEIGHT - this.player.y) / (CANVAS_HEIGHT - this.goalY) * 100);
                const displayProgress = Math.min(99.9, progress); // Cap at 99.9% until goal
                progressFill.style.width = displayProgress + "%";
                progressText.textContent = displayProgress.toFixed(1) + "%";
                
                if (progress > this.bestProgress) {
                    this.bestProgress = progress;
                }

                // Evil: Wind in hell zone (last 1%) - annoying but manageable
                if (progress > 99) {
                    this.windTimer++;
                    if (this.windTimer % 120 < 60) {
                        this.wind = Math.sin(this.windTimer * 0.08) * 1.2;
                    } else {
                        this.wind = Math.sin(this.windTimer * 0.05) * 1.8;
                    }
                } else {
                    this.wind = 0;
                }

                // Update platforms
                for (const platform of this.platforms) {
                    platform.update();
                }

                // Update player
                this.player.update(this.keys, this.platforms, this.wind);

                // Check spike collision
                for (const spike of this.spikes) {
                    if (spike.checkCollision(this.player)) {
                        this.gameState = "DEAD";
                    }
                }

                // Camera follows player
                const targetCameraY = this.player.y - CANVAS_HEIGHT / 3;
                this.cameraY += (targetCameraY - this.cameraY) * 0.1;

                // Check if player fell
                if (this.player.isDead(this.cameraY)) {
                    this.gameState = "DEAD";
                }

                // Check if reached goal
                if (this.player.y <= this.goalY + 50 && 
                    this.player.x > CANVAS_WIDTH / 2 - 75 && 
                    this.player.x < CANVAS_WIDTH / 2 + 75) {
                    this.gameState = "WON";
                    progressFill.style.width = "100%";
                    progressText.textContent = "100%";
                }
            }

            draw() {
                // Clear canvas
                ctx.fillStyle = "#1a1a2e";
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // Draw stars background
                ctx.fillStyle = "white";
                for (let i = 0; i < 50; i++) {
                    const x = (i * 73) % CANVAS_WIDTH;
                    const y = ((i * 97 + this.cameraY * 0.2) % CANVAS_HEIGHT);
                    ctx.fillRect(x, y, 2, 2);
                }

                // Draw goal door (always visible)
                const goalScreenY = this.goalY - this.cameraY;
                if (goalScreenY < CANVAS_HEIGHT && goalScreenY > -300) {
                    // Draw glowing door
                    ctx.fillStyle = "#FFD700";
                    ctx.fillRect(CANVAS_WIDTH / 2 - 60, goalScreenY - 200, 120, 150);
                    
                    // Door details
                    ctx.fillStyle = "#FFA500";
                    ctx.fillRect(CANVAS_WIDTH / 2 - 50, goalScreenY - 190, 100, 130);
                    
                    ctx.fillStyle = "#FFD700";
                    ctx.fillRect(CANVAS_WIDTH / 2 - 10, goalScreenY - 120, 20, 20);
                    
                    // Glow effect
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = "#FFD700";
                    ctx.fillRect(CANVAS_WIDTH / 2 - 60, goalScreenY - 200, 120, 150);
                    ctx.shadowBlur = 0;
                    
                    // "GOAL" text
                    ctx.fillStyle = "white";
                    ctx.font = "20px Arial";
                    ctx.textAlign = "center";
                    ctx.fillText("GOAL", CANVAS_WIDTH / 2, goalScreenY - 220);
                }

                // Draw platforms
                for (const platform of this.platforms) {
                    platform.draw(this.cameraY);
                }

                // Draw spikes
                for (const spike of this.spikes) {
                    spike.draw(this.cameraY);
                }

                // Draw player
                this.player.draw(this.cameraY);

                // Draw wind indicator in hell zone
                if (this.wind !== 0) {
                    ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
                    ctx.font = "24px Arial";
                    ctx.textAlign = "center";
                    const windText = this.wind > 0 ? "‚Üí WIND ‚Üí" : "‚Üê WIND ‚Üê";
                    ctx.fillText(windText, CANVAS_WIDTH / 2, 100);
                }

                // Draw messages
                if (this.gameState === "START") {
                    this.drawText("The golden door awaits...", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 40, "24px Arial", "white");
                    this.drawText("Press SPACE to start", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20, "20px Arial", "#888");
                    this.drawText("(It looks easy... trust me, it's not)", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 60, "14px Arial", "#ff9800");
                } else if (this.gameState === "DEAD") {
                    this.drawText("YOU FELL!", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 60, "48px Arial", "#e74c3c");
                    this.drawText(`Best: ${this.bestProgress.toFixed(1)}%`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, "28px Arial", "white");
                    this.drawText(`Attempts: ${this.attempts}`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 40, "20px Arial", "#888");
                    this.drawText("Press R to try again", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 80, "18px Arial", "#4CAF50");
                } else if (this.gameState === "WON") {
                    this.drawText("üéâ YOU DID IT! üéâ", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 60, "42px Arial", "#FFD700");
                    this.drawText("You reached 100%!", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, "28px Arial", "white");
                    this.drawText(`After ${this.attempts} attempts`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 40, "20px Arial", "#888");
                    this.drawText("You're a legend!", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 80, "18px Arial", "#4CAF50");
                    this.drawText("Press R to play again", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 110, "16px Arial", "#888");
                }
            }

            drawText(text, x, y, font, color) {
                ctx.font = font;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";

                // Shadow
                ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
                ctx.fillText(text, x + 2, y + 2);

                // Text
                ctx.fillStyle = color;
                ctx.fillText(text, x, y);
            }
        }

        // Initialize game
        const game = new Game();

        // Game loop
        function gameLoop() {
            game.update();
            game.draw();
            requestAnimationFrame(gameLoop);
        }

        // Event handlers
        function onKeyDown(event) {
            game.keys[event.key] = true;
            
            if (event.key === " " || event.key === "Spacebar") {
                event.preventDefault();
                if (game.gameState === "START") {
                    game.start();
                } else if (game.gameState === "PLAYING") {
                    game.player.jump();
                }
            } else if (event.key === "r" || event.key === "R") {
                if (game.gameState === "DEAD" || game.gameState === "WON") {
                    game.start();
                }
            }
        }

        function onKeyUp(event) {
            game.keys[event.key] = false;
        }

        function onClick(event) {
            // Don't prevent default if clicking on a link
            if (event.target.tagName === 'A') {
                return;
            }
            
            if (game.gameState === "START") {
                game.start();
            }
            // DEAD and WON now only restart with 'R' key
        }

        // Attach event listeners
        document.addEventListener("keydown", onKeyDown);
        document.addEventListener("keyup", onKeyUp);
        canvas.addEventListener("click", onClick);

        // Mobile Touch Controls
        const btnLeft = document.getElementById('btn-left');
        const btnRight = document.getElementById('btn-right');

        // Side buttons for movement
        function setupSideButton(btn, key) {
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                btn.classList.add('pressed');
                game.keys[key] = true;
            }, { passive: false });

            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                btn.classList.remove('pressed');
                game.keys[key] = false;
            }, { passive: false });

            btn.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                e.stopPropagation();
                btn.classList.remove('pressed');
                game.keys[key] = false;
            }, { passive: false });
        }

        setupSideButton(btnLeft, 'ArrowLeft');
        setupSideButton(btnRight, 'ArrowRight');

        // Canvas tap = JUMP
        canvas.addEventListener('touchend', (e) => {
            // Check if touch was on canvas (not on side buttons)
            const rect = canvas.getBoundingClientRect();
            const touch = e.changedTouches[0];
            const x = touch.clientX - rect.left;
            
            // Only jump if touch was in the middle area (not on side buttons)
            if (x > 80 && x < rect.width - 80) {
                e.preventDefault();
                if (game.gameState === "START") {
                    game.start();
                } else if (game.gameState === "PLAYING") {
                    game.player.jump();
                } else if (game.gameState === "DEAD" || game.gameState === "WON") {
                    game.start();
                }
            }
        }, { passive: false });

        // Info modal functionality
        const infoBtn = document.getElementById('infoBtn');
        const infoModal = document.getElementById('infoModal');
        const closeModal = document.querySelector('.close-modal');
        
        if (infoBtn) {
            infoBtn.addEventListener('click', () => {
                infoModal.style.display = 'block';
            });
        }
        
        if (closeModal) {
            closeModal.addEventListener('click', () => {
                infoModal.style.display = 'none';
            });
        }
        
        window.addEventListener('click', (e) => {
            if (e.target === infoModal) {
                infoModal.style.display = 'none';
            }
        });

        // Start game loop
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
