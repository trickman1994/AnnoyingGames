<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy Bird - Game Arcade</title>
    <link rel="stylesheet" href="/static/css/main.css">
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        
        #game-container {
            position: relative;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 20px;
        }
        
        #gameCanvas {
            display: block;
            background: #70c5ce;
            cursor: pointer;
        }
        
        #score-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 48px;
            font-weight: bold;
            color: white;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            z-index: 10;
        }
        
        .instructions {
            margin-top: 20px;
            color: white;
            text-align: center;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .instructions h2 {
            margin-bottom: 10px;
        }
        
        .instructions p {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <!-- Back Button -->
    <a href="/" class="back-button">Home</a>

    <div id="game-container">
        <canvas id="gameCanvas" width="480" height="640"></canvas>
        <div id="score-display">0</div>
    </div>
    
    <div class="instructions">
        <h2>ðŸŽ® Flappy Bird</h2>
        <p>Press <strong>SPACE</strong> or <strong>CLICK</strong> to jump</p>
        <p>Press <strong>R</strong> to restart when game over</p>
    </div>

    <script>
        // Get canvas and context
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const scoreDisplay = document.getElementById("score-display");

        // Game constants
        const CANVAS_WIDTH = 480;
        const CANVAS_HEIGHT = 640;
        const GRAVITY = 0.6;
        const JUMP_STRENGTH = -10;
        const BIRD_SIZE = 34;
        const PIPE_WIDTH = 70;
        const PIPE_GAP = 180;
        const PIPE_SPEED = 3;
        const GROUND_HEIGHT = 80;

        // Bird class
        class Bird {
            constructor() {
                this.x = 100;
                this.y = CANVAS_HEIGHT / 2;
                this.velocity = 0;
                this.size = BIRD_SIZE;
            }

            jump() {
                this.velocity = JUMP_STRENGTH;
            }

            update() {
                this.velocity += GRAVITY;
                this.y += this.velocity;
            }

            draw() {
                // Draw bird body (yellow circle)
                ctx.fillStyle = "#FFD700";
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
                ctx.fill();

                // Draw bird eye (white circle)
                ctx.fillStyle = "white";
                ctx.beginPath();
                ctx.arc(this.x + 8, this.y - 5, 6, 0, Math.PI * 2);
                ctx.fill();

                // Draw pupil (black circle)
                ctx.fillStyle = "black";
                ctx.beginPath();
                ctx.arc(this.x + 10, this.y - 5, 3, 0, Math.PI * 2);
                ctx.fill();

                // Draw beak (orange triangle)
                ctx.fillStyle = "#FF8C00";
                ctx.beginPath();
                ctx.moveTo(this.x + this.size / 2 - 5, this.y);
                ctx.lineTo(this.x + this.size / 2 + 10, this.y - 3);
                ctx.lineTo(this.x + this.size / 2 + 10, this.y + 3);
                ctx.closePath();
                ctx.fill();
            }

            getBounds() {
                return {
                    x: this.x - this.size / 2,
                    y: this.y - this.size / 2,
                    width: this.size,
                    height: this.size
                };
            }
        }

        // Pipe class
        class Pipe {
            constructor(x) {
                this.x = x;
                this.width = PIPE_WIDTH;
                this.gap = PIPE_GAP;
                this.topHeight = Math.floor(Math.random() * (CANVAS_HEIGHT - GROUND_HEIGHT - this.gap - 200)) + 100;
                this.passed = false;
            }

            update() {
                this.x -= PIPE_SPEED;
            }

            draw() {
                // Draw top pipe
                ctx.fillStyle = "#4CAF50";
                ctx.fillRect(this.x, 0, this.width, this.topHeight);

                // Draw top pipe cap
                ctx.fillStyle = "#45a049";
                ctx.fillRect(this.x - 5, this.topHeight - 30, this.width + 10, 30);

                // Draw bottom pipe
                const bottomY = this.topHeight + this.gap;
                ctx.fillStyle = "#4CAF50";
                ctx.fillRect(this.x, bottomY, this.width, CANVAS_HEIGHT - GROUND_HEIGHT - bottomY);

                // Draw bottom pipe cap
                ctx.fillStyle = "#45a049";
                ctx.fillRect(this.x - 5, bottomY, this.width + 10, 30);
            }

            offScreen() {
                return this.x + this.width < 0;
            }

            getBounds() {
                return {
                    top: { x: this.x, y: 0, width: this.width, height: this.topHeight },
                    bottom: { 
                        x: this.x, 
                        y: this.topHeight + this.gap, 
                        width: this.width, 
                        height: CANVAS_HEIGHT - GROUND_HEIGHT - this.topHeight - this.gap 
                    }
                };
            }
        }

        // Game class
        class Game {
            constructor() {
                this.bird = new Bird();
                this.pipes = [];
                this.score = 0;
                this.gameState = "START"; // START, PLAYING, GAME_OVER
                this.frameCount = 0;
                this.pipeFrequency = 90; // frames between pipes
            }

            start() {
                this.bird = new Bird();
                this.pipes = [];
                this.score = 0;
                this.gameState = "PLAYING";
                this.frameCount = 0;
                scoreDisplay.textContent = "0";
            }

            update() {
                if (this.gameState !== "PLAYING") {
                    return;
                }

                this.bird.update();
                this.frameCount++;

                // Generate pipes
                if (this.frameCount % this.pipeFrequency === 0) {
                    this.pipes.push(new Pipe(CANVAS_WIDTH));
                }

                // Update pipes
                for (let i = this.pipes.length - 1; i >= 0; i--) {
                    const pipe = this.pipes[i];
                    pipe.update();

                    // Check if bird passed pipe
                    if (!pipe.passed && pipe.x + pipe.width < this.bird.x) {
                        pipe.passed = true;
                        this.score++;
                        scoreDisplay.textContent = this.score.toString();
                    }

                    // Remove off-screen pipes
                    if (pipe.offScreen()) {
                        this.pipes.splice(i, 1);
                    }
                }

                // Check collisions
                if (this.checkCollision()) {
                    this.gameState = "GAME_OVER";
                }
            }

            checkCollision() {
                const birdBounds = this.bird.getBounds();

                // Check ground collision
                if (this.bird.y + BIRD_SIZE / 2 >= CANVAS_HEIGHT - GROUND_HEIGHT) {
                    return true;
                }

                // Check ceiling collision
                if (this.bird.y - BIRD_SIZE / 2 <= 0) {
                    return true;
                }

                // Check pipe collision
                for (const pipe of this.pipes) {
                    const pipeBounds = pipe.getBounds();

                    // Check collision with top pipe
                    if (this.rectsCollide(birdBounds, pipeBounds.top)) {
                        return true;
                    }

                    // Check collision with bottom pipe
                    if (this.rectsCollide(birdBounds, pipeBounds.bottom)) {
                        return true;
                    }
                }

                return false;
            }

            rectsCollide(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }

            draw() {
                // Clear canvas
                ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // Draw sky gradient
                const gradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
                gradient.addColorStop(0, "#70c5ce");
                gradient.addColorStop(1, "#a8e6f0");
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // Draw clouds
                this.drawClouds();

                // Draw pipes
                for (const pipe of this.pipes) {
                    pipe.draw();
                }

                // Draw ground
                ctx.fillStyle = "#DEB887";
                ctx.fillRect(0, CANVAS_HEIGHT - GROUND_HEIGHT, CANVAS_WIDTH, GROUND_HEIGHT);

                // Draw grass on ground
                ctx.fillStyle = "#90EE90";
                ctx.fillRect(0, CANVAS_HEIGHT - GROUND_HEIGHT, CANVAS_WIDTH, 20);

                // Draw bird
                this.bird.draw();

                // Draw game state messages
                if (this.gameState === "START") {
                    this.drawText("Click or Press SPACE to Start", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, "30px Arial", "white");
                } else if (this.gameState === "GAME_OVER") {
                    this.drawText("GAME OVER!", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 40, "48px Arial", "#FF4444");
                    this.drawText(`Score: ${this.score}`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20, "32px Arial", "white");
                    this.drawText("Press R to Restart", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 70, "24px Arial", "white");
                }
            }

            drawClouds() {
                ctx.fillStyle = "rgba(255, 255, 255, 0.5)";

                // Static clouds for simplicity
                const cloudPositions = [[100, 100], [300, 150], [400, 80], [150, 250], [350, 300]];

                for (const [x, y] of cloudPositions) {
                    // Draw simple cloud (3 circles)
                    ctx.beginPath();
                    ctx.arc(x, y, 25, 0, Math.PI * 2);
                    ctx.arc(x + 25, y, 30, 0, Math.PI * 2);
                    ctx.arc(x + 50, y, 25, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            drawText(text, x, y, font, color) {
                ctx.font = font;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";

                // Draw shadow
                ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
                ctx.fillText(text, x + 3, y + 3);

                // Draw text
                ctx.fillStyle = color;
                ctx.fillText(text, x, y);
            }
        }

        // Initialize game
        const game = new Game();

        // Game loop
        function gameLoop() {
            game.update();
            game.draw();
            requestAnimationFrame(gameLoop);
        }

        // Event handlers
        function onKeyDown(event) {
            const key = event.key;
            console.log("Key pressed:", key, "Game state:", game.gameState);

            if (key === " " || key === "Spacebar") {
                event.preventDefault();
                if (game.gameState === "START") {
                    console.log("Starting game...");
                    game.start();
                } else if (game.gameState === "PLAYING") {
                    console.log("Bird jumping...");
                    game.bird.jump();
                }
            } else if (key === "r" || key === "R") {
                if (game.gameState === "GAME_OVER") {
                    game.start();
                }
            }
        }

        function onClick(event) {
            // Don't prevent default if clicking on a link
            if (event.target.tagName === 'A') {
                return;
            }
            
            event.preventDefault();
            console.log("Click detected! Game state:", game.gameState);
            
            if (game.gameState === "START") {
                console.log("Starting game from click...");
                game.start();
            } else if (game.gameState === "PLAYING") {
                console.log("Bird jumping from click...");
                game.bird.jump();
            }
        }

        // Attach event listeners
        document.addEventListener("keydown", onKeyDown);
        canvas.addEventListener("click", onClick);
        document.body.addEventListener("click", onClick);

        console.log("Game initialized! Click or press SPACE to start.");
        console.log("Canvas element:", canvas);
        console.log("Event listeners attached.");

        // Start game loop
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
