<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Demon Cards - AI Own You</title>
    <link rel="stylesheet" href="/static/css/main.css">
    <style>
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            max-height: 100vh;
            background: #000;
            margin: 0;
            padding: 5px;
            overflow: hidden;
            touch-action: none;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 600px;
            padding: 8px 15px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            margin-bottom: 5px;
            flex-shrink: 0;
        }
        
        .header-btn {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            text-decoration: none;
            cursor: pointer;
            font-size: 14px;
        }
        
        .game-title {
            color: white;
            font-size: 18px;
            margin: 0;
            text-align: center;
            flex: 1;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 0;
        }
        
        #gameCanvas {
            display: block;
            background: #000;
            cursor: pointer;
            touch-action: none;
            width: 100%;
            height: auto;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
        }
        
        .modal-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            margin: 5% auto;
            padding: 20px;
            border-radius: 10px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            border: 2px solid #8B0000;
        }
        
        .close-modal {
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: white;
        }

        .modal-body h3 {
            color: #FF6B6B;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <header class="game-header">
        <a href="/" class="header-btn home-btn">‚Üê Home</a>
        <h1 class="game-title">üëπ Demon Cards</h1>
        <button class="header-btn info-btn" id="infoBtn">‚ÑπÔ∏è</button>
    </header>

    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="1200"></canvas>
    </div>

    <!-- Info Modal -->
    <div id="infoModal" class="modal">
        <div class="modal-content">
            <span class="close-modal">&times;</span>
            <h2>üëπ Demon Cards - How to Play</h2>
            <div class="modal-body">
                <h3>Objective</h3>
                <p>Defeat the Shadow Demon before it defeats you! Click cards as they fall to reveal their power. Use strategy and luck to survive.</p>
                
                <h3>Card Types</h3>
                <p><strong>üî¥ Red (Attack):</strong> Deal damage to the boss</p>
                <p><strong>üîµ Blue (Defense):</strong> Shield yourself from damage</p>
                <p><strong>üü£ Purple (Curse):</strong> Negative effects - be careful!</p>
                <p><strong>üü¢ Green (Heal):</strong> Restore your health</p>
                <p><strong>üü° Gold (Special):</strong> Powerful unique effects</p>
                
                <h3>Rules</h3>
                <p>‚Ä¢ Cards fall from top to bottom - click them to reveal</p>
                <p>‚Ä¢ Cards queue up - order matters for combos!</p>
                <p>‚Ä¢ The boss attacks periodically</p>
                <p>‚Ä¢ Defeat the boss before your health reaches 0</p>
                
                <h3>Strategy</h3>
                <p>Choose cards wisely! The colored back hints at the category. Card order creates powerful combos!</p>
            </div>
        </div>
    </div>

    <script>
        // Get canvas and context
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");

        // Canvas dimensions
        const BASE_WIDTH = 800;
        const BASE_HEIGHT = 1200;
        let CANVAS_WIDTH = BASE_WIDTH;
        let CANVAS_HEIGHT = BASE_HEIGHT;

        // Resize canvas
        function resizeCanvas() {
            const header = document.querySelector('.game-header');
            const headerHeight = header ? header.offsetHeight + 10 : 70;
            const padding = 5;
            
            const availableHeight = window.innerHeight - headerHeight - padding;
            const availableWidth = window.innerWidth - padding * 2;
            
            const aspectRatio = BASE_WIDTH / BASE_HEIGHT;
            let height = availableHeight;
            let width = height * aspectRatio;
            
            if (width > availableWidth) {
                width = availableWidth;
                height = width / aspectRatio;
            }
            
            if (width > BASE_WIDTH) {
                width = BASE_WIDTH;
                height = BASE_HEIGHT;
            }
            if (height > BASE_HEIGHT) {
                height = BASE_HEIGHT;
                width = BASE_WIDTH;
            }
            
            canvas.width = BASE_WIDTH;
            canvas.height = BASE_HEIGHT;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            
            CANVAS_WIDTH = BASE_WIDTH;
            CANVAS_HEIGHT = BASE_HEIGHT;
        }

        resizeCanvas();
        setTimeout(resizeCanvas, 100);
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeCanvas, 200);
        });

        // Modal functionality
        const infoBtn = document.getElementById('infoBtn');
        const infoModal = document.getElementById('infoModal');
        const closeModal = document.querySelector('.close-modal');
        
        if (infoBtn) {
            infoBtn.addEventListener('click', () => {
                infoModal.style.display = 'block';
            });
        }
        
        if (closeModal) {
            closeModal.addEventListener('click', () => {
                infoModal.style.display = 'none';
            });
        }
        
        window.addEventListener('click', (e) => {
            if (e.target === infoModal) {
                infoModal.style.display = 'none';
            }
        });

        // ====================================
        // GAME CODE
        // ====================================

        // Card Types
        const CARD_TYPES = {
            ATTACK: { name: "Attack", color: "#FF4444", backColor: "#8B0000", symbol: "‚öîÔ∏è" },
            DEFENSE: { name: "Defense", color: "#4444FF", backColor: "#00008B", symbol: "üõ°Ô∏è" },
            CURSE: { name: "Curse", color: "#AA44AA", backColor: "#4B0082", symbol: "üíÄ" },
            HEAL: { name: "Heal", color: "#44FF44", backColor: "#006400", symbol: "üíö" },
            SPECIAL: { name: "Special", color: "#FFD700", backColor: "#8B7500", symbol: "‚≠ê" }
        };

        // Particle
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8 - 2;
                this.color = color;
                this.life = 1.0;
                this.size = 3 + Math.random() * 5;
            }

            update(deltaTime) {
                this.x += this.vx * deltaTime * 60;
                this.y += this.vy * deltaTime * 60;
                this.vy += 0.2 * deltaTime * 60;
                this.life -= 0.02 * deltaTime * 60;
            }

            draw() {
                if (this.life <= 0) return;
                ctx.save();
                ctx.globalAlpha = this.life;
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size * 2);
                gradient.addColorStop(0, this.color);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // Floating Text
        class FloatingText {
            constructor(x, y, text, color) {
                this.x = x;
                this.y = y;
                this.text = text;
                this.color = color;
                this.life = 1.0;
                this.vy = -30;
            }

            update(deltaTime) {
                this.y += this.vy * deltaTime;
                this.life -= 0.8 * deltaTime;
            }

            draw() {
                if (this.life <= 0) return;
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.font = "bold 32px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.strokeStyle = "#000000";
                ctx.lineWidth = 4;
                ctx.strokeText(this.text, this.x, this.y);
                ctx.fillStyle = this.color;
                ctx.fillText(this.text, this.x, this.y);
                ctx.restore();
            }
        }

        // Mystery Card (on board)
        class MysteryCard {
            constructor(x, y, index) {
                this.x = x;
                this.y = y;
                this.index = index;
                this.revealed = false;
                this.isGood = false; // Will be set randomly
                this.multiplier = this.generateMultiplier(); // x1, x2, x3, x5, etc.
                this.width = 65; // Optimized size to fit all cards
                this.height = 90; // Optimized size to fit all cards
                this.glow = 0;
                this.pulse = Math.random() * Math.PI * 2;
            }

            generateMultiplier() {
                // Good cards: x1, x2, x3, x5 (weighted towards lower)
                // Bad cards: x1, x2, x3, x5 (weighted towards higher)
                const multipliers = [1, 2, 3, 5];
                const weights = [0.4, 0.3, 0.2, 0.1]; // More likely to get x1
                let rand = Math.random();
                let sum = 0;
                for (let i = 0; i < weights.length; i++) {
                    sum += weights[i];
                    if (rand <= sum) {
                        return multipliers[i];
                    }
                }
                return multipliers[0];
            }

            reveal() {
                if (this.revealed) return;
                this.revealed = true;
                this.glow = 1.0;
                
                const cx = this.x + this.width / 2;
                const cy = this.y + this.height / 2;
                
                // Particles
                const color = this.isGood ? "#44FF44" : "#FF4444";
                for (let i = 0; i < 30; i++) {
                    game.particles.push(new Particle(cx, cy, color));
                }
                
                // Screen flash
                game.screenFlash = { color: color, life: 0.3 };
                game.screenShake = 0.3;
            }

            update(deltaTime) {
                this.glow = Math.max(0, this.glow - 0.05 * deltaTime * 60);
                this.pulse += 0.1 * deltaTime * 60;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                
                // Glow if revealed
                if (this.revealed && this.glow > 0) {
                    const color = this.isGood ? "#44FF44" : "#FF4444";
                    for (let i = 0; i < 5; i++) {
                        const size = this.width * (1 + i * 0.8) * this.glow * 1.5;
                        const alpha = (this.glow * 0.5) / (i + 1);
                        const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
                        const hexAlpha = Math.floor(alpha * 255).toString(16).padStart(2, '0');
                        grad.addColorStop(0, color + hexAlpha);
                        grad.addColorStop(1, 'transparent');
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.arc(0, 0, size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                if (!this.revealed) {
                    // MYSTERIOUS ARTISTIC CARD BACK
                    const pulseSize = 1 + Math.sin(this.pulse) * 0.1;
                    ctx.scale(pulseSize, pulseSize);
                    
                    // Dark base with gradient
                    const baseGradient = ctx.createLinearGradient(-this.width / 2, -this.height / 2, this.width / 2, this.height / 2);
                    baseGradient.addColorStop(0, "#2a2a3a");
                    baseGradient.addColorStop(0.5, "#1a1a2a");
                    baseGradient.addColorStop(1, "#0a0a1a");
                    ctx.fillStyle = baseGradient;
                    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    
                    // Mystical pattern overlay
                    ctx.strokeStyle = "#4a4a6a";
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.6;
                    
                    // Swirling pattern
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        const angle = this.pulse + i * (Math.PI * 2 / 3);
                        const radius = this.width * 0.3;
                        ctx.arc(Math.cos(angle) * radius * 0.5, Math.sin(angle) * radius * 0.5, radius, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    // Central symbol (mystical eye/star) - BIGGER AND CLEARER
                    ctx.globalAlpha = 0.9;
                    ctx.strokeStyle = "#8a8aaa";
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    // Star shape - larger
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const radius = i % 2 === 0 ? this.width * 0.2 : this.width * 0.35;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    
                    // Additional inner circle for clarity
                    ctx.strokeStyle = "#6a6a8a";
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width * 0.15, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Glowing center
                    const centerGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, this.width * 0.2);
                    centerGlow.addColorStop(0, "#6a6a8a80");
                    centerGlow.addColorStop(1, 'transparent');
                    ctx.fillStyle = centerGlow;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Border with subtle glow
                    ctx.globalAlpha = 1.0;
                    ctx.strokeStyle = "#5a5a7a";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    ctx.strokeStyle = "#3a3a5a";
                    ctx.lineWidth = 1;
                    ctx.strokeRect(-this.width / 2 + 2, -this.height / 2 + 2, this.width - 4, this.height - 4);
                } else {
                    // Revealed card with multiplier
                    const color = this.isGood ? "#44FF44" : "#FF4444";
                    const gradient = ctx.createLinearGradient(-this.width / 2, -this.height / 2, this.width / 2, this.height / 2);
                    gradient.addColorStop(0, color);
                    gradient.addColorStop(1, this.isGood ? "#006400" : "#8B0000");
                    ctx.fillStyle = gradient;
                    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    ctx.strokeStyle = "#FFFFFF";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    
                    // Multiplier text - BIGGER AND CLEARER
                    ctx.font = "bold 40px Arial";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillStyle = "#FFFFFF";
                    ctx.strokeStyle = "#000000";
                    ctx.lineWidth = 4;
                    const multText = `x${this.multiplier}`;
                    ctx.strokeText(multText, 0, 0);
                    ctx.fillText(multText, 0, 0);
                    
                    // Good/Bad indicator - BIGGER
                    ctx.font = "bold 28px Arial";
                    ctx.fillText(this.isGood ? "‚úì" : "‚úó", 0, -this.height * 0.35);
                }
                ctx.restore();
            }

            checkHit(x, y) {
                return x >= this.x && x <= this.x + this.width &&
                       y >= this.y && y <= this.y + this.height;
            }
        }

        // Falling Card (for stacking)
        class FallingCard {
            constructor(x, type) {
                this.x = x;
                this.y = 470; // Start below collected counters box (380 + 90 box height)
                this.type = type;
                this.revealed = false;
                this.width = 80;
                this.height = 120;
                this.speed = (1.5 + Math.random() * 1) * 5 * 0.49; // Reduced by 30% more (0.7 * 0.7)
                this.multiplier = this.generateMultiplier(); // Random multiplier for falling cards
                this.value = this.generateValue();
                this.glow = 0;
                this.fadeOut = 1.0;
            }

            generateMultiplier() {
                // Random multiplier x1, x2, x3, x5
                const multipliers = [1, 2, 3, 5];
                const weights = [0.4, 0.3, 0.2, 0.1];
                let rand = Math.random();
                let sum = 0;
                for (let i = 0; i < weights.length; i++) {
                    sum += weights[i];
                    if (rand <= sum) {
                        return multipliers[i];
                    }
                }
                return multipliers[0];
            }

            generateValue() {
                // Only damage and health now (no shield)
                if (this.type === CARD_TYPES.ATTACK || this.type === CARD_TYPES.CURSE) {
                    return { damage: 10 + Math.floor(Math.random() * 20), health: 0 };
                } else if (this.type === CARD_TYPES.HEAL) {
                    return { damage: 0, health: 10 + Math.floor(Math.random() * 20) };
                } else {
                    // Mixed cards
                    return { 
                        damage: 5 + Math.floor(Math.random() * 15), 
                        health: 5 + Math.floor(Math.random() * 15) 
                    };
                }
            }

            reveal() {
                if (this.revealed) return;
                this.revealed = true;
                this.glow = 1.0;
                
                const cx = this.x + this.width / 2;
                const cy = this.y + this.height / 2;
                
                // Reduced particles - still impressive but not overwhelming
                for (let i = 0; i < 40; i++) {
                    game.particles.push(new Particle(cx, cy, this.type.color));
                }
                
                // Reduced particle rings
                for (let ring = 0; ring < 2; ring++) {
                    const ringRadius = (ring + 1) * 40;
                    const particlesPerRing = 15;
                    for (let i = 0; i < particlesPerRing; i++) {
                        const angle = (i / particlesPerRing) * Math.PI * 2;
                        const px = cx + Math.cos(angle) * ringRadius;
                        const py = cy + Math.sin(angle) * ringRadius;
                        game.particles.push(new Particle(px, py, this.type.color));
                    }
                }
                
                // Reduced screen flash
                game.screenFlash = { 
                    color: this.type.color, 
                    life: 0.4,
                    intensity: 0.7,
                    layers: 1
                };
                game.screenShake = 0.3;
                
                // Reduced light streaks
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    game.lightStreaks.push({
                        x: cx,
                        y: cy,
                        angle: angle,
                        length: 150 + Math.random() * 50,
                        life: 0.3,
                        color: this.type.color
                    });
                }
            }

            update(deltaTime) {
                if (!this.revealed) {
                    this.y += this.speed * deltaTime * 60;
                } else {
                    // Fade out after reveal
                    this.fadeOut -= 0.8 * deltaTime; // Fade out quickly
                    this.glow = Math.max(0, this.glow - 0.05 * deltaTime * 60);
                }
            }

            isDead() {
                return this.revealed && this.fadeOut <= 0;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                
                // Apply fade out
                if (this.revealed) {
                    ctx.globalAlpha = this.fadeOut;
                }
                
                if (!this.revealed) {
                    // Enhanced card back with glow
                    const cardGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, this.width);
                    cardGlow.addColorStop(0, this.type.color + "40");
                    cardGlow.addColorStop(1, "transparent");
                    ctx.fillStyle = cardGlow;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width * 0.8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Card back with gradient
                    const backGradient = ctx.createLinearGradient(-this.width / 2, -this.height / 2, this.width / 2, this.height / 2);
                    backGradient.addColorStop(0, this.type.backColor);
                    backGradient.addColorStop(0.5, this.type.color + "80");
                    backGradient.addColorStop(1, this.type.backColor);
                    ctx.fillStyle = backGradient;
                    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    
                    // Enhanced border with glow
                    ctx.strokeStyle = this.type.color;
                    ctx.lineWidth = 4;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = this.type.color;
                    ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    ctx.shadowBlur = 0;
                    
                    // Symbol with glow
                    ctx.font = "30px Arial";
                    ctx.textAlign = "center";
                    ctx.fillStyle = this.type.color;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = this.type.color;
                    ctx.globalAlpha = 0.8;
                    ctx.fillText(this.type.symbol, 0, -15);
                    ctx.globalAlpha = 1.0;
                    ctx.shadowBlur = 0;
                    
                    // Enhanced multiplier display
                    ctx.font = "bold 28px Arial";
                    ctx.fillStyle = "#FFD700";
                    ctx.strokeStyle = "#000000";
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = "#FFD700";
                    const multText = `x${this.multiplier}`;
                    ctx.strokeText(multText, 0, 15);
                    ctx.fillText(multText, 0, 15);
                    ctx.shadowBlur = 0;
                } else {
                    // Reduced but still impressive glow
                    if (this.glow > 0) {
                        const pulse = Math.sin(Date.now() / 50) * 0.15 + 0.85;
                        for (let i = 0; i < 5; i++) {
                            const size = this.width * (1 + i * 1.5) * this.glow * 1.8;
                            const alpha = (this.glow * 0.7 * pulse) / (i + 1);
                            const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
                            const hexAlpha = Math.floor(Math.min(255, alpha * 255)).toString(16).padStart(2, '0');
                            grad.addColorStop(0, this.type.color + hexAlpha);
                            grad.addColorStop(0.3, this.type.color + Math.floor(alpha * 0.6 * 255).toString(16).padStart(2, '0'));
                            grad.addColorStop(1, 'transparent');
                            ctx.fillStyle = grad;
                            ctx.beginPath();
                            ctx.arc(0, 0, size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // Reduced pulsing rings
                        for (let ring = 0; ring < 3; ring++) {
                            const ringPhase = (Date.now() / 60 + ring * 0.8) % (Math.PI * 2);
                            const pulseSize = this.width * (2 + Math.sin(ringPhase) * 1) * this.glow;
                            const pulseAlpha = (Math.sin(ringPhase) * 0.4 + 0.4) * this.glow * 0.4;
                            const pulseGrad = ctx.createRadialGradient(0, 0, this.width, 0, 0, pulseSize);
                            const ringAlpha = Math.floor(pulseAlpha * 255).toString(16).padStart(2, '0');
                            pulseGrad.addColorStop(0, this.type.color + ringAlpha);
                            pulseGrad.addColorStop(0.5, this.type.color + Math.floor(pulseAlpha * 0.3 * 255).toString(16).padStart(2, '0'));
                            pulseGrad.addColorStop(1, 'transparent');
                            ctx.fillStyle = pulseGrad;
                            ctx.beginPath();
                            ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    
                    // Enhanced card face with shine effect
                    const gradient = ctx.createLinearGradient(-this.width / 2, -this.height / 2, this.width / 2, this.height / 2);
                    gradient.addColorStop(0, this.type.color);
                    gradient.addColorStop(0.5, this.type.color + "CC");
                    gradient.addColorStop(1, this.type.backColor);
                    ctx.fillStyle = gradient;
                    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    
                    // Shine overlay
                    const shineGradient = ctx.createLinearGradient(-this.width / 2, -this.height / 2, -this.width / 2, this.height / 2);
                    shineGradient.addColorStop(0, "rgba(255, 255, 255, 0.4)");
                    shineGradient.addColorStop(0.5, "rgba(255, 255, 255, 0.1)");
                    shineGradient.addColorStop(1, "transparent");
                    ctx.fillStyle = shineGradient;
                    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    
                    // Enhanced border
                    ctx.strokeStyle = "#FFFFFF";
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = "#FFFFFF";
                    ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    ctx.shadowBlur = 0;
                    
                    // Enhanced symbol
                    ctx.font = "bold 40px Arial";
                    ctx.textAlign = "center";
                    ctx.fillStyle = "#FFFFFF";
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = this.type.color;
                    ctx.fillText(this.type.symbol, 0, -20);
                    ctx.shadowBlur = 0;
                    ctx.font = "bold 20px Arial";
                    // Show stacked values
                    if (this.value.damage > 0) {
                        ctx.fillText(`‚öîÔ∏è${Math.round(this.value.damage)}`, -20, 20);
                    }
                    if (this.value.health > 0) {
                        ctx.fillText(`üíö${Math.round(this.value.health)}`, 20, 20);
                    }
                    // Show multiplier on falling card
                    ctx.font = "bold 28px Arial";
                    ctx.fillStyle = "#FFD700";
                    ctx.strokeStyle = "#000000";
                    ctx.lineWidth = 3;
                    const multText = `x${this.multiplier}`;
                    ctx.strokeText(multText, 0, 50);
                    ctx.fillText(multText, 0, 50);
                }
                ctx.restore();
            }

            checkHit(x, y) {
                return x >= this.x && x <= this.x + this.width &&
                       y >= this.y && y <= this.y + this.height;
            }
        }

        // Boss - EXTREMELY REALISTIC AND IMPRESSIVE
        class Boss {
            constructor() {
                this.maxHealth = 2167; // Increased by 30% (1667 * 1.3)
                this.health = this.maxHealth;
                this.x = CANVAS_WIDTH / 2;
                this.y = 150; // Moved lower so health bar is fully visible
                this.size = 140; // Slightly bigger for more detail
                this.animationTime = 0;
                this.attackTimer = 0;
                this.attackCooldown = 3.0;
                this.hornAngle = 0; // For horn animation
            }

            update(deltaTime) {
                this.animationTime += deltaTime;
                this.attackTimer += deltaTime;
                this.hornAngle += deltaTime * 0.5; // Slow horn sway
                
                // Spawn ambient particles around boss
                if (Math.random() < 0.1) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = this.size * (0.8 + Math.random() * 0.4);
                    const px = this.x + Math.cos(angle) * dist;
                    const py = this.y + Math.sin(angle) * dist;
                    game.particles.push(new Particle(px, py, "#8B0000"));
                }
                
                if (this.attackTimer >= this.attackCooldown && game.gameState === "PLAYING") {
                    this.attack();
                    this.attackTimer = 0;
                }
            }

            attack() {
                const damage = 8 + Math.floor(Math.random() * 12);
                game.takeDamage(damage);
                game.screenShake = 0.3;
            }

            takeDamage(amount) {
                this.health = Math.max(0, this.health - amount);
                game.floatingTexts.push(new FloatingText(this.x, this.y - this.size, `-${amount}`, "#FF4444"));
                
                if (this.health <= 0) {
                    game.gameState = "WON";
                }
            }

            draw() {
                ctx.save();
                
                // ULTRA REALISTIC MULTIPLE LAYERED SHADOWS with soft edges
                for (let i = 0; i < 8; i++) {
                    const shadowSize = this.size * (0.9 - i * 0.08);
                    const shadowY = this.y + this.size + 15 + i * 3;
                    const shadowAlpha = (0.7 - i * 0.08) * (0.8 + Math.sin(this.animationTime * 2) * 0.2);
                    const shadowBlur = 5 + i * 2;
                    
                    ctx.shadowBlur = shadowBlur;
                    ctx.shadowColor = `rgba(0, 0, 0, ${shadowAlpha})`;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                    ctx.fillStyle = `rgba(0, 0, 0, ${shadowAlpha * 0.5})`;
                    ctx.beginPath();
                    ctx.ellipse(this.x, shadowY, shadowSize, shadowSize * 0.25, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.shadowBlur = 0;
                
                // ULTRA REALISTIC MULTIPLE GLOW LAYERS with atmospheric effects
                for (let i = 0; i < 12; i++) {
                    const glowSize = this.size * (1.2 + i * 0.25);
                    const glowIntensity = (0.5 - i * 0.04) * (0.7 + Math.sin(this.animationTime * 2.5 + i * 0.5) * 0.3);
                    const pulse = Math.sin(this.animationTime * 3 + i * 0.3) * 0.15 + 0.85;
                    const glowGradient = ctx.createRadialGradient(this.x, this.y - this.size * 0.2, 0, this.x, this.y, glowSize);
                    const red = Math.max(50, 180 - i * 8);
                    const green = Math.max(0, 20 - i * 2);
                    const blue = 0;
                    glowGradient.addColorStop(0, `rgba(${red}, ${green}, ${blue}, ${glowIntensity * pulse * 0.8})`);
                    glowGradient.addColorStop(0.3, `rgba(${red}, ${green}, ${blue}, ${glowIntensity * pulse * 0.5})`);
                    glowGradient.addColorStop(0.6, `rgba(${red}, ${green}, ${blue}, ${glowIntensity * pulse * 0.2})`);
                    glowGradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.translate(this.x, this.y);
                const subtleRot = Math.sin(this.animationTime * 0.4) * 0.03;
                ctx.rotate(subtleRot);
                
                // ULTRA REALISTIC HORNS - Curved, detailed, with texture
                const hornBaseY = -this.size * 0.75;
                const hornBaseX = this.size * 0.35;
                const hornLength = this.size * 0.75;
                const hornSway = Math.sin(this.hornAngle) * 0.08;
                const hornCurve = 0.15;
                
                // Left horn - curved and detailed
                ctx.save();
                ctx.translate(-hornBaseX, hornBaseY);
                ctx.rotate(-0.4 + hornSway);
                
                // Horn base with realistic texture
                const hornBaseGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size * 0.12);
                hornBaseGradient.addColorStop(0, "#4a2a2a");
                hornBaseGradient.addColorStop(0.5, "#2a1a1a");
                hornBaseGradient.addColorStop(1, "#1a0a0a");
                ctx.fillStyle = hornBaseGradient;
                ctx.beginPath();
                ctx.arc(0, 0, this.size * 0.12, 0, Math.PI * 2);
                ctx.fill();
                
                // Curved horn body with multiple segments
                for (let seg = 0; seg < 8; seg++) {
                    const segProgress = seg / 8;
                    const segY = -hornLength * segProgress;
                    const segWidth = this.size * 0.08 * (1 - segProgress * 0.6);
                    const segCurve = hornCurve * segProgress;
                    
                    const segGradient = ctx.createLinearGradient(-segWidth, segY, segWidth, segY);
                    segGradient.addColorStop(0, "#3a2a2a");
                    segGradient.addColorStop(0.3, "#2a1a1a");
                    segGradient.addColorStop(0.7, "#1a0a0a");
                    segGradient.addColorStop(1, "#0a0000");
                    ctx.fillStyle = segGradient;
                    ctx.beginPath();
                    ctx.ellipse(segCurve * this.size * 0.1, segY, segWidth, segWidth * 0.6, segProgress * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Segment highlight
                    ctx.fillStyle = `rgba(150, 80, 80, ${0.2 * (1 - segProgress)})`;
                    ctx.beginPath();
                    ctx.ellipse(segCurve * this.size * 0.1 - segWidth * 0.3, segY, segWidth * 0.4, segWidth * 0.3, segProgress * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Horn rings/texture
                ctx.strokeStyle = "rgba(50, 25, 25, 0.6)";
                ctx.lineWidth = 1.5;
                for (let ring = 1; ring < 6; ring++) {
                    const ringY = -hornLength * (ring / 6);
                    const ringWidth = this.size * 0.08 * (1 - ring / 6 * 0.6);
                    ctx.beginPath();
                    ctx.ellipse(hornCurve * this.size * 0.1 * (ring / 6), ringY, ringWidth, ringWidth * 0.6, ring / 6 * 0.3, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.restore();
                
                // Right horn - curved and detailed
                ctx.save();
                ctx.translate(hornBaseX, hornBaseY);
                ctx.rotate(0.4 - hornSway);
                
                // Horn base
                ctx.fillStyle = hornBaseGradient;
                ctx.beginPath();
                ctx.arc(0, 0, this.size * 0.12, 0, Math.PI * 2);
                ctx.fill();
                
                // Curved horn body
                for (let seg = 0; seg < 8; seg++) {
                    const segProgress = seg / 8;
                    const segY = -hornLength * segProgress;
                    const segWidth = this.size * 0.08 * (1 - segProgress * 0.6);
                    const segCurve = -hornCurve * segProgress;
                    
                    const segGradient = ctx.createLinearGradient(-segWidth, segY, segWidth, segY);
                    segGradient.addColorStop(0, "#3a2a2a");
                    segGradient.addColorStop(0.3, "#2a1a1a");
                    segGradient.addColorStop(0.7, "#1a0a0a");
                    segGradient.addColorStop(1, "#0a0000");
                    ctx.fillStyle = segGradient;
                    ctx.beginPath();
                    ctx.ellipse(segCurve * this.size * 0.1, segY, segWidth, segWidth * 0.6, -segProgress * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Segment highlight
                    ctx.fillStyle = `rgba(150, 80, 80, ${0.2 * (1 - segProgress)})`;
                    ctx.beginPath();
                    ctx.ellipse(segCurve * this.size * 0.1 + segWidth * 0.3, segY, segWidth * 0.4, segWidth * 0.3, -segProgress * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Horn rings
                ctx.strokeStyle = "rgba(50, 25, 25, 0.6)";
                ctx.lineWidth = 1.5;
                for (let ring = 1; ring < 6; ring++) {
                    const ringY = -hornLength * (ring / 6);
                    const ringWidth = this.size * 0.08 * (1 - ring / 6 * 0.6);
                    ctx.beginPath();
                    ctx.ellipse(-hornCurve * this.size * 0.1 * (ring / 6), ringY, ringWidth, ringWidth * 0.6, -ring / 6 * 0.3, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.restore();
                
                // ULTRA REALISTIC HEAD STRUCTURE - Not just a sphere, but a detailed head
                // Head shape - more oval/realistic proportions
                const headWidth = this.size;
                const headHeight = this.size * 1.15;
                
                // OPTIMIZED REALISTIC OUTER GLOW - 12 layers for performance
                for (let glowLayer = 0; glowLayer < 12; glowLayer++) {
                    const glowSize = this.size * (1.02 + glowLayer * 0.1);
                    const glowAlpha = (0.6 - glowLayer * 0.04) * (0.7 + Math.sin(this.animationTime * 2 + glowLayer * 0.2) * 0.3);
                    const outerGlow = ctx.createRadialGradient(0, -this.size * 0.1, 0, 0, 0, glowSize);
                    const red = Math.max(50, 180 - glowLayer * 8);
                    const green = Math.max(0, 40 - glowLayer * 3);
                    const blue = 0;
                    outerGlow.addColorStop(0, `rgba(${red}, ${green}, ${blue}, ${glowAlpha})`);
                    outerGlow.addColorStop(0.4, `rgba(${Math.max(30, red - 30)}, ${Math.max(0, green - 10)}, 0, ${glowAlpha * 0.6})`);
                    outerGlow.addColorStop(0.7, `rgba(${Math.max(20, red - 50)}, ${Math.max(0, green - 20)}, 0, ${glowAlpha * 0.3})`);
                    outerGlow.addColorStop(1, "transparent");
                    ctx.fillStyle = outerGlow;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, glowSize, glowSize * 1.1, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // OPTIMIZED REALISTIC HEAD SHAPE - Smooth gradient with 15 stops
                // Primary light from top-left
                const mainBodyGradient = ctx.createRadialGradient(
                    -this.size * 0.4, -this.size * 0.5, 0,
                    0, this.size * 0.2, this.size * 1.2
                );
                // Smooth gradient with optimized stops
                mainBodyGradient.addColorStop(0, "#8a6a6a"); // Brightest highlight
                mainBodyGradient.addColorStop(0.08, "#7a5a5a");
                mainBodyGradient.addColorStop(0.15, "#6a4a4a");
                mainBodyGradient.addColorStop(0.25, "#5a3a3a"); // Bright highlight
                mainBodyGradient.addColorStop(0.35, "#4a2a2a");
                mainBodyGradient.addColorStop(0.45, "#3a2a2a"); // Mid highlight
                mainBodyGradient.addColorStop(0.55, "#2a1a1a"); // Base
                mainBodyGradient.addColorStop(0.65, "#1a0a0a");
                mainBodyGradient.addColorStop(0.75, "#0a0000"); // Shadow
                mainBodyGradient.addColorStop(0.85, "#050000");
                mainBodyGradient.addColorStop(0.92, "#020000");
                mainBodyGradient.addColorStop(1, "#000000"); // Darkest
                ctx.fillStyle = mainBodyGradient;
                ctx.beginPath();
                ctx.ellipse(0, 0, headWidth, headHeight, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Additional light sources for realistic multi-bounce lighting
                // Fill light from bottom-right
                const fillLightGradient = ctx.createRadialGradient(
                    this.size * 0.3, this.size * 0.4, 0,
                    0, 0, this.size * 0.9
                );
                fillLightGradient.addColorStop(0, "rgba(60, 30, 20, 0.2)");
                fillLightGradient.addColorStop(0.5, "rgba(40, 20, 10, 0.1)");
                fillLightGradient.addColorStop(1, "transparent");
                ctx.fillStyle = fillLightGradient;
                ctx.beginPath();
                ctx.ellipse(0, 0, headWidth * 0.95, headHeight * 0.95, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Key light bounce from left
                const bounceLightGradient = ctx.createLinearGradient(
                    -this.size * 0.5, -this.size * 0.6,
                    this.size * 0.2, this.size * 0.3
                );
                bounceLightGradient.addColorStop(0, "rgba(80, 50, 30, 0.15)");
                bounceLightGradient.addColorStop(0.5, "rgba(50, 30, 15, 0.08)");
                bounceLightGradient.addColorStop(1, "transparent");
                ctx.fillStyle = bounceLightGradient;
                ctx.beginPath();
                ctx.ellipse(0, 0, headWidth * 0.85, headHeight * 0.85, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // SUBSURFACE SCATTERING - Realistic skin translucency
                const sssGradient = ctx.createRadialGradient(
                    -this.size * 0.3, -this.size * 0.4, 0,
                    0, 0, this.size * 0.8
                );
                sssGradient.addColorStop(0, "rgba(139, 50, 30, 0.15)");
                sssGradient.addColorStop(0.5, "rgba(100, 30, 15, 0.1)");
                sssGradient.addColorStop(1, "transparent");
                ctx.fillStyle = sssGradient;
                ctx.beginPath();
                ctx.ellipse(0, 0, headWidth * 0.9, headHeight * 0.9, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Secondary light source from right (rim light)
                const rimLightGradient = ctx.createLinearGradient(
                    this.size * 0.6, -this.size * 0.8,
                    this.size * 0.8, this.size * 0.8
                );
                rimLightGradient.addColorStop(0, "rgba(139, 50, 0, 0.5)");
                rimLightGradient.addColorStop(0.5, "rgba(100, 30, 0, 0.3)");
                rimLightGradient.addColorStop(1, "transparent");
                ctx.fillStyle = rimLightGradient;
                ctx.beginPath();
                ctx.ellipse(0, 0, headWidth, headHeight, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // OPTIMIZED REALISTIC SKIN TEXTURE - Efficient but detailed
                // Use pattern-based approach for better performance
                // Layer 1: Large pores (optimized count)
                ctx.fillStyle = "rgba(30, 10, 10, 0.4)";
                for (let i = 0; i < 80; i++) {
                    const angle = (i / 80) * Math.PI * 2;
                    const dist = this.size * (0.15 + Math.random() * 0.75);
                    const x = Math.cos(angle) * dist;
                    const y = Math.sin(angle) * dist * 1.1;
                    const poreSize = 1.5 + Math.random() * 2.5;
                    ctx.beginPath();
                    ctx.arc(x, y, poreSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Layer 2: Medium pores (optimized count)
                ctx.fillStyle = "rgba(25, 8, 8, 0.35)";
                for (let i = 0; i < 150; i++) {
                    const angle = (i / 150) * Math.PI * 2;
                    const dist = this.size * (0.2 + Math.random() * 0.7);
                    const x = Math.cos(angle) * dist;
                    const y = Math.sin(angle) * dist * 1.1;
                    const poreSize = 0.8 + Math.random() * 1.5;
                    ctx.beginPath();
                    ctx.arc(x, y, poreSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Layer 3: Small pores (optimized count)
                ctx.fillStyle = "rgba(20, 5, 5, 0.3)";
                for (let i = 0; i < 250; i++) {
                    const angle = (i / 250) * Math.PI * 2;
                    const dist = this.size * (0.25 + Math.random() * 0.65);
                    const x = Math.cos(angle) * dist;
                    const y = Math.sin(angle) * dist * 1.1;
                    const poreSize = 0.3 + Math.random() * 0.8;
                    ctx.beginPath();
                    ctx.arc(x, y, poreSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Skin bumps and irregularities (optimized)
                for (let i = 0; i < 60; i++) {
                    const angle = (i / 60) * Math.PI * 2;
                    const dist = this.size * (0.3 + Math.random() * 0.6);
                    const x = Math.cos(angle) * dist;
                    const y = Math.sin(angle) * dist * 1.1;
                    const bumpSize = 2 + Math.random() * 3;
                    const bumpGradient = ctx.createRadialGradient(x, y, 0, x, y, bumpSize);
                    bumpGradient.addColorStop(0, "rgba(40, 15, 15, 0.4)");
                    bumpGradient.addColorStop(1, "transparent");
                    ctx.fillStyle = bumpGradient;
                    ctx.beginPath();
                    ctx.arc(x, y, bumpSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Skin surface variations (optimized)
                ctx.fillStyle = "rgba(25, 10, 10, 0.2)";
                for (let i = 0; i < 100; i++) {
                    const angle = (i / 100) * Math.PI * 2;
                    const dist = this.size * (0.3 + Math.random() * 0.6);
                    const x = Math.cos(angle) * dist;
                    const y = Math.sin(angle) * dist * 1.1;
                    const scaleSize = 3 + Math.random() * 4;
                    ctx.beginPath();
                    ctx.ellipse(x, y, scaleSize, scaleSize * 0.6, Math.random() * Math.PI, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // OPTIMIZED REALISTIC WRINKLES AND FACIAL STRUCTURE
                // Forehead wrinkles - optimized count
                ctx.strokeStyle = "rgba(20, 5, 5, 0.5)";
                ctx.lineWidth = 2;
                for (let i = 0; i < 10; i++) {
                    const y = -this.size * 0.65 + i * this.size * 0.08;
                    const wrinkleWidth = this.size * (0.35 + Math.random() * 0.1);
                    const wrinkleHeight = this.size * (0.03 + Math.random() * 0.02);
                    ctx.beginPath();
                    ctx.ellipse(0, y, wrinkleWidth, wrinkleHeight, 0, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Micro-wrinkles on forehead (optimized)
                ctx.strokeStyle = "rgba(15, 3, 3, 0.35)";
                ctx.lineWidth = 1;
                for (let i = 0; i < 25; i++) {
                    const y = -this.size * 0.7 + Math.random() * this.size * 0.3;
                    const x = (Math.random() - 0.5) * this.size * 0.5;
                    ctx.beginPath();
                    ctx.moveTo(x - this.size * 0.15, y);
                    ctx.lineTo(x + this.size * 0.15, y);
                    ctx.stroke();
                }
                
                // Cheek lines - detailed
                ctx.strokeStyle = "rgba(20, 5, 5, 0.5)";
                ctx.lineWidth = 1.5;
                for (let side = -1; side <= 1; side += 2) {
                    for (let i = 0; i < 5; i++) {
                        const x = side * this.size * (0.25 + i * 0.08);
                        const y = this.size * (0.05 + i * 0.12);
                        const length = this.size * (0.08 + Math.random() * 0.05);
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x + side * length, y + this.size * 0.15);
                        ctx.stroke();
                    }
                }
                
                // Nasolabial folds
                for (let side = -1; side <= 1; side += 2) {
                    ctx.strokeStyle = "rgba(25, 8, 8, 0.6)";
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(side * this.size * 0.2, -this.size * 0.1);
                    ctx.quadraticCurveTo(side * this.size * 0.35, this.size * 0.2, side * this.size * 0.4, this.size * 0.4);
                    ctx.stroke();
                }
                
                // Brow ridge shadow
                ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
                ctx.beginPath();
                ctx.ellipse(0, -this.size * 0.5, this.size * 0.6, this.size * 0.08, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Cheekbone highlights
                for (let side = -1; side <= 1; side += 2) {
                    const cheekGradient = ctx.createRadialGradient(
                        side * this.size * 0.35, this.size * 0.15, 0,
                        side * this.size * 0.35, this.size * 0.15, this.size * 0.2
                    );
                    cheekGradient.addColorStop(0, "rgba(80, 40, 30, 0.3)");
                    cheekGradient.addColorStop(1, "transparent");
                    ctx.fillStyle = cheekGradient;
                    ctx.beginPath();
                    ctx.arc(side * this.size * 0.35, this.size * 0.15, this.size * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Jawline definition
                ctx.strokeStyle = "rgba(15, 5, 5, 0.4)";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.ellipse(0, this.size * 0.6, this.size * 0.5, this.size * 0.1, 0, 0, Math.PI * 2);
                ctx.stroke();
                
                // Realistic rim lighting for 3D separation
                const rimGradient = ctx.createLinearGradient(
                    -this.size, -this.size * 1.1,
                    this.size, this.size * 1.1
                );
                rimGradient.addColorStop(0, "rgba(139, 50, 0, 0.6)");
                rimGradient.addColorStop(0.3, "transparent");
                rimGradient.addColorStop(0.7, "transparent");
                rimGradient.addColorStop(1, "rgba(139, 50, 0, 0.6)");
                ctx.strokeStyle = rimGradient;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.ellipse(0, 0, headWidth, headHeight, 0, 0, Math.PI * 2);
                ctx.stroke();
                
                // Additional depth with ambient occlusion
                const aoGradient = ctx.createRadialGradient(
                    this.size * 0.3, this.size * 0.4, 0,
                    0, 0, this.size * 1.1
                );
                aoGradient.addColorStop(0, "transparent");
                aoGradient.addColorStop(0.7, "transparent");
                aoGradient.addColorStop(1, "rgba(0, 0, 0, 0.4)");
                ctx.fillStyle = aoGradient;
                ctx.beginPath();
                ctx.ellipse(0, 0, headWidth, headHeight, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // ULTRA REALISTIC EYES - Anatomically correct with depth
                const eyeGlow = Math.sin(this.animationTime * 4) * 0.25 + 0.75;
                const eyePulse = Math.sin(this.animationTime * 6) * 0.08 + 1;
                const eyeBlink = Math.sin(this.animationTime * 8) > 0.95 ? 0.3 : 1; // Occasional blink
                
                // Left eye - ultra detailed
                ctx.save();
                ctx.translate(-this.size * 0.32, -this.size * 0.18);
                
                // Eye socket depth with realistic shadow
                const socketGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size * 0.22);
                socketGradient.addColorStop(0, "rgba(0, 0, 0, 0.9)");
                socketGradient.addColorStop(0.6, "rgba(0, 0, 0, 0.7)");
                socketGradient.addColorStop(1, "rgba(20, 5, 5, 0.5)");
                ctx.fillStyle = socketGradient;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size * 0.2, this.size * 0.16, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Eye outer glow - multiple layers
                for (let glowLayer = 0; glowLayer < 4; glowLayer++) {
                    const glowSize = this.size * (0.22 + glowLayer * 0.08);
                    const glowAlpha = (0.7 - glowLayer * 0.15) * eyeGlow;
                    const eyeGlowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
                    eyeGlowGradient.addColorStop(0, `rgba(255, ${30 + glowLayer * 10}, 0, ${glowAlpha})`);
                    eyeGlowGradient.addColorStop(0.4, `rgba(200, 0, 0, ${glowAlpha * 0.6})`);
                    eyeGlowGradient.addColorStop(1, "transparent");
                    ctx.fillStyle = eyeGlowGradient;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, glowSize, glowSize * 0.8, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Eyelid/upper shadow
                ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
                ctx.beginPath();
                ctx.ellipse(0, -this.size * 0.08, this.size * 0.18, this.size * 0.1, 0, 0, Math.PI, 0, false);
                ctx.fill();
                
                // Eye white (sclera) - if not blinking
                if (eyeBlink > 0.5) {
                    ctx.fillStyle = "rgba(200, 180, 180, 0.3)";
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.size * 0.18 * eyePulse, this.size * 0.14 * eyePulse, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Iris with realistic texture
                const irisSize = this.size * 0.14 * eyePulse * eyeBlink;
                const irisGradient = ctx.createRadialGradient(0, -this.size * 0.03, 0, 0, 0, irisSize);
                irisGradient.addColorStop(0, `rgba(255, ${80 + eyeGlow * 40}, 0, ${eyeGlow})`);
                irisGradient.addColorStop(0.3, `rgba(255, 40, 0, ${eyeGlow})`);
                irisGradient.addColorStop(0.6, `rgba(200, 0, 0, ${eyeGlow})`);
                irisGradient.addColorStop(1, `rgba(139, 0, 0, ${eyeGlow})`);
                ctx.fillStyle = irisGradient;
                ctx.beginPath();
                ctx.ellipse(0, 0, irisSize, irisSize * 0.85, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Iris texture lines
                ctx.strokeStyle = `rgba(139, 0, 0, ${eyeGlow * 0.6})`;
                ctx.lineWidth = 1;
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(angle) * irisSize * 0.7, Math.sin(angle) * irisSize * 0.6);
                    ctx.stroke();
                }
                
                // Pupil
                const pupilSize = this.size * 0.08 * eyePulse * eyeBlink;
                ctx.fillStyle = `rgba(0, 0, 0, ${0.9 + eyeGlow * 0.1})`;
                ctx.beginPath();
                ctx.ellipse(0, 0, pupilSize, pupilSize * 0.9, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Multiple eye highlights for realism
                // Main highlight
                ctx.fillStyle = `rgba(255, 255, 255, ${eyeGlow * 0.8})`;
                ctx.beginPath();
                ctx.ellipse(-this.size * 0.03, -this.size * 0.05, this.size * 0.06, this.size * 0.05, 0, 0, Math.PI * 2);
                ctx.fill();
                // Secondary highlight
                ctx.fillStyle = `rgba(255, 255, 255, ${eyeGlow * 0.4})`;
                ctx.beginPath();
                ctx.ellipse(this.size * 0.04, -this.size * 0.04, this.size * 0.03, this.size * 0.025, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Eyelid lower shadow
                ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
                ctx.beginPath();
                ctx.ellipse(0, this.size * 0.08, this.size * 0.18, this.size * 0.08, 0, 0, Math.PI, 0, true);
                ctx.fill();
                
                ctx.restore();
                
                // Right eye - ultra detailed (same as left)
                ctx.save();
                ctx.translate(this.size * 0.32, -this.size * 0.18);
                
                // Eye socket
                ctx.fillStyle = socketGradient;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size * 0.2, this.size * 0.16, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Eye outer glow
                for (let glowLayer = 0; glowLayer < 4; glowLayer++) {
                    const glowSize = this.size * (0.22 + glowLayer * 0.08);
                    const glowAlpha = (0.7 - glowLayer * 0.15) * eyeGlow;
                    const eyeGlowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
                    eyeGlowGradient.addColorStop(0, `rgba(255, ${30 + glowLayer * 10}, 0, ${glowAlpha})`);
                    eyeGlowGradient.addColorStop(0.4, `rgba(200, 0, 0, ${glowAlpha * 0.6})`);
                    eyeGlowGradient.addColorStop(1, "transparent");
                    ctx.fillStyle = eyeGlowGradient;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, glowSize, glowSize * 0.8, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Eyelid upper
                ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
                ctx.beginPath();
                ctx.ellipse(0, -this.size * 0.08, this.size * 0.18, this.size * 0.1, 0, 0, Math.PI, 0, false);
                ctx.fill();
                
                // Eye white
                if (eyeBlink > 0.5) {
                    ctx.fillStyle = "rgba(200, 180, 180, 0.3)";
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.size * 0.18 * eyePulse, this.size * 0.14 * eyePulse, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Iris
                ctx.fillStyle = irisGradient;
                ctx.beginPath();
                ctx.ellipse(0, 0, irisSize, irisSize * 0.85, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Iris texture
                ctx.strokeStyle = `rgba(139, 0, 0, ${eyeGlow * 0.6})`;
                ctx.lineWidth = 1;
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(angle) * irisSize * 0.7, Math.sin(angle) * irisSize * 0.6);
                    ctx.stroke();
                }
                
                // Pupil
                ctx.fillStyle = `rgba(0, 0, 0, ${0.9 + eyeGlow * 0.1})`;
                ctx.beginPath();
                ctx.ellipse(0, 0, pupilSize, pupilSize * 0.9, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Highlights
                ctx.fillStyle = `rgba(255, 255, 255, ${eyeGlow * 0.8})`;
                ctx.beginPath();
                ctx.ellipse(-this.size * 0.03, -this.size * 0.05, this.size * 0.06, this.size * 0.05, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = `rgba(255, 255, 255, ${eyeGlow * 0.4})`;
                ctx.beginPath();
                ctx.ellipse(this.size * 0.04, -this.size * 0.04, this.size * 0.03, this.size * 0.025, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Eyelid lower
                ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
                ctx.beginPath();
                ctx.ellipse(0, this.size * 0.08, this.size * 0.18, this.size * 0.08, 0, 0, Math.PI, 0, true);
                ctx.fill();
                
                ctx.restore();
                
                // ULTRA REALISTIC MOUTH - Detailed with depth
                const mouthY = this.size * 0.35;
                const mouthWidth = this.size * 0.25;
                const mouthHeight = this.size * 0.18;
                
                // Mouth opening shadow/depth
                const mouthShadowGradient = ctx.createRadialGradient(0, mouthY, 0, 0, mouthY, mouthWidth);
                mouthShadowGradient.addColorStop(0, "rgba(0, 0, 0, 1)");
                mouthShadowGradient.addColorStop(0.5, "rgba(0, 0, 0, 0.9)");
                mouthShadowGradient.addColorStop(1, "rgba(20, 0, 0, 0.6)");
                ctx.fillStyle = mouthShadowGradient;
                ctx.beginPath();
                ctx.ellipse(0, mouthY, mouthWidth, mouthHeight, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner mouth glow
                const innerMouthGlow = ctx.createRadialGradient(0, mouthY - mouthHeight * 0.3, 0, 0, mouthY, mouthWidth * 0.8);
                innerMouthGlow.addColorStop(0, "rgba(139, 0, 0, 0.4)");
                innerMouthGlow.addColorStop(1, "rgba(0, 0, 0, 0.8)");
                ctx.fillStyle = innerMouthGlow;
                ctx.beginPath();
                ctx.ellipse(0, mouthY, mouthWidth * 0.9, mouthHeight * 0.8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Realistic teeth - upper row
                ctx.fillStyle = "rgba(240, 240, 230, 0.9)";
                for (let i = -2; i <= 2; i++) {
                    const toothX = i * this.size * 0.06;
                    const toothY = mouthY - mouthHeight * 0.3;
                    const toothWidth = this.size * 0.04;
                    const toothHeight = this.size * 0.06;
                    
                    // Tooth shape
                    ctx.beginPath();
                    ctx.moveTo(toothX, toothY);
                    ctx.lineTo(toothX - toothWidth * 0.5, toothY + toothHeight);
                    ctx.lineTo(toothX + toothWidth * 0.5, toothY + toothHeight);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Tooth highlight
                    ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
                    ctx.beginPath();
                    ctx.moveTo(toothX, toothY);
                    ctx.lineTo(toothX - toothWidth * 0.3, toothY + toothHeight * 0.5);
                    ctx.lineTo(toothX + toothWidth * 0.1, toothY + toothHeight * 0.5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = "rgba(240, 240, 230, 0.9)";
                }
                
                // Realistic teeth - lower row
                for (let i = -2; i <= 2; i++) {
                    const toothX = i * this.size * 0.06;
                    const toothY = mouthY + mouthHeight * 0.3;
                    const toothWidth = this.size * 0.04;
                    const toothHeight = this.size * 0.06;
                    
                    // Tooth shape
                    ctx.beginPath();
                    ctx.moveTo(toothX, toothY);
                    ctx.lineTo(toothX - toothWidth * 0.5, toothY - toothHeight);
                    ctx.lineTo(toothX + toothWidth * 0.5, toothY - toothHeight);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Tooth highlight
                    ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
                    ctx.beginPath();
                    ctx.moveTo(toothX, toothY);
                    ctx.lineTo(toothX - toothWidth * 0.3, toothY - toothHeight * 0.5);
                    ctx.lineTo(toothX + toothWidth * 0.1, toothY - toothHeight * 0.5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = "rgba(240, 240, 230, 0.9)";
                }
                
                // Tongue (if mouth open enough)
                const tongueGradient = ctx.createRadialGradient(0, mouthY + mouthHeight * 0.2, 0, 0, mouthY, mouthWidth * 0.6);
                tongueGradient.addColorStop(0, "rgba(139, 50, 50, 0.8)");
                tongueGradient.addColorStop(1, "rgba(100, 20, 20, 0.6)");
                ctx.fillStyle = tongueGradient;
                ctx.beginPath();
                ctx.ellipse(0, mouthY + mouthHeight * 0.1, mouthWidth * 0.5, mouthHeight * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Additional detail - cracks/veins
                ctx.strokeStyle = "rgba(139, 0, 0, 0.4)";
                ctx.lineWidth = 2;
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI * 2;
                    const startDist = this.size * 0.6;
                    const endDist = this.size * 0.9;
                    ctx.beginPath();
                    ctx.moveTo(
                        Math.cos(angle) * startDist,
                        Math.sin(angle) * startDist
                    );
                    ctx.lineTo(
                        Math.cos(angle) * endDist,
                        Math.sin(angle) * endDist
                    );
                    ctx.stroke();
                }
                
                ctx.restore();
                
                // Health bar - BIGGER AND MORE VISIBLE
                const barWidth = 250;
                const barHeight = 25;
                const barX = this.x - barWidth / 2;
                const barY = 60; // Moved lower to be fully visible
                
                ctx.fillStyle = "#333";
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                const healthPercent = this.health / this.maxHealth;
                const healthGradient = ctx.createLinearGradient(barX, barY, barX + barWidth, barY);
                healthGradient.addColorStop(0, "#FF0000");
                healthGradient.addColorStop(healthPercent, "#FF4444");
                healthGradient.addColorStop(healthPercent, "#333");
                healthGradient.addColorStop(1, "#333");
                ctx.fillStyle = healthGradient;
                ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
                
                ctx.strokeStyle = "#FFF";
                ctx.lineWidth = 3;
                ctx.strokeRect(barX, barY, barWidth, barHeight);
                
                // Health numbers - BIGGER AND MORE VISIBLE
                ctx.font = "bold 22px Arial";
                ctx.textAlign = "center";
                ctx.fillStyle = "#FFFFFF";
                ctx.strokeStyle = "#000000";
                ctx.lineWidth = 4;
                const healthText = `${Math.ceil(this.health)}/${this.maxHealth}`;
                ctx.strokeText(healthText, this.x, barY - 8);
                ctx.fillText(healthText, this.x, barY - 8);
                
                // Label - removed to save space, health numbers are clear enough
            }
        }

        // Game
        class Game {
            constructor() {
                this.gameState = "START";
                this.fallingCards = []; // Cards that fall from top
                this.mysteryCards = []; // 32 mystery cards on board
                this.particles = [];
                this.floatingTexts = [];
                this.lightStreaks = []; // For hyperbolic card click effects
                this.boss = new Boss();
                this.playerHealth = 1416; // Increased by 70% (833 * 1.7)
                this.maxPlayerHealth = 1416;
                this.applyEffectAnimation = null; // For showing applied values
                this.spawnTimer = 0;
                this.spawnInterval = 1.2;
                this.screenShake = 0;
                this.shakeX = 0;
                this.shakeY = 0;
                this.screenFlash = null;
                
                // Round system
                this.stackedDamage = 0; // Stacked damage from falling cards
                this.stackedHealth = 0; // Stacked health from falling cards
                this.cardsOpened = 0; // How many mystery cards opened (max 25)
                this.goodCardsOpened = 0; // How many good cards opened (max 16)
                this.allGoodRevealed = false; // If all 16 good cards are opened
                this.roundActive = false;
                
                // Batch system for falling cards
                this.batchSize = 15; // Cards per batch
                this.cardsInBatch = 0; // How many cards spawned in current batch
                this.cardsPickedFromBatch = 0; // How many cards picked from current batch (max 7)
                this.waitingForMysteryCard = false; // True when waiting for player to pick mystery card
                this.batchMessage = null; // Message to show in middle area
                
                this.initMysteryCards();
            }
            
            initMysteryCards() {
                // Create 32 mystery cards on LEFT and RIGHT sides (2 columns x 8 rows each)
                // Falling cards will be in the MIDDLE area
                this.mysteryCards = [];
                const cardSpacingY = 85; // Vertical spacing between rows
                const startY = 400; // Start below boss and collected values
                
                // Left side: 2 columns x 8 rows = 16 cards (vertical layout)
                const leftStartX = 50;
                const leftSpacingX = 70; // Spacing between the 2 columns
                
                // Right side: 2 columns x 8 rows = 16 cards (vertical layout)
                const rightStartX = CANVAS_WIDTH - 50 - (2 * 70);
                const rightSpacingX = 70; // Spacing between the 2 columns
                
                // Randomly assign 16 good, 16 bad - MIXED ACROSS BOTH SIDES
                const assignments = [];
                for (let i = 0; i < 16; i++) assignments.push(true);
                for (let i = 0; i < 16; i++) assignments.push(false);
                // Shuffle thoroughly
                for (let i = assignments.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [assignments[i], assignments[j]] = [assignments[j], assignments[i]];
                }
                
                // Create all card positions first, then randomly assign good/bad
                const allPositions = [];
                
                // Left side positions (16 cards: 8 rows x 2 columns)
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 2; col++) {
                        allPositions.push({
                            x: leftStartX + col * leftSpacingX,
                            y: startY + row * cardSpacingY
                        });
                    }
                }
                
                // Right side positions (16 cards: 8 rows x 2 columns)
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 2; col++) {
                        allPositions.push({
                            x: rightStartX + col * rightSpacingX,
                            y: startY + row * cardSpacingY
                        });
                    }
                }
                
                // Shuffle positions to mix left and right
                for (let i = allPositions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allPositions[i], allPositions[j]] = [allPositions[j], allPositions[i]];
                }
                
                // Create cards with random assignments
                for (let i = 0; i < 32; i++) {
                    const pos = allPositions[i];
                    const card = new MysteryCard(pos.x, pos.y, i);
                    card.isGood = assignments[i];
                    this.mysteryCards.push(card);
                }
            }

            start() {
                this.gameState = "PLAYING";
                this.fallingCards = [];
                this.particles = [];
                this.floatingTexts = [];
                this.lightStreaks = [];
                this.boss = new Boss();
                this.playerHealth = 1416;
                this.stackedDamage = 0;
                this.stackedHealth = 0;
                this.cardsOpened = 0;
                this.goodCardsOpened = 0;
                this.allGoodRevealed = false;
                this.roundActive = true;
                this.applyEffectAnimation = null;
                this.cardsInBatch = 0;
                this.cardsPickedFromBatch = 0;
                this.waitingForMysteryCard = false;
                this.batchMessage = null;
                this.initMysteryCards();
                this.startNewBatch(); // Start first batch
            }
            
            startNewBatch() {
                // Remove all unpicked falling cards
                this.fallingCards = this.fallingCards.filter(card => card.revealed);
                this.cardsInBatch = 0;
                this.cardsPickedFromBatch = 0;
                this.waitingForMysteryCard = false;
                this.batchMessage = null;
            }

            spawnCard() {
                // Don't spawn if batch is complete or waiting for mystery card
                if (this.waitingForMysteryCard || this.cardsInBatch >= this.batchSize) {
                    return;
                }
                
                // Spawn falling cards in the MIDDLE area (where mystery cards were)
                // Middle area: 300 to 500
                const middleStartX = 300;
                const middleEndX = 500;
                const x = middleStartX + Math.random() * (middleEndX - middleStartX);
                
                // Only spawn damage or health cards (no shield)
                const types = [CARD_TYPES.ATTACK, CARD_TYPES.HEAL];
                // Sometimes mixed cards
                if (Math.random() < 0.3) {
                    types.push(CARD_TYPES.SPECIAL);
                }
                const type = types[Math.floor(Math.random() * types.length)];
                this.fallingCards.push(new FallingCard(x, type));
                this.cardsInBatch++;
                
                // If batch is complete, show message (but player can still pick cards)
                if (this.cardsInBatch >= this.batchSize) {
                    this.waitingForMysteryCard = true;
                    this.batchMessage = "Select a closed card!";
                }
            }

            handleClick(x, y) {
                if (this.gameState === "START") {
                    this.start();
                    return;
                }
                
                if (this.gameState !== "PLAYING") {
                    if (this.gameState === "WON" || this.gameState === "LOST") {
                        this.start();
                    }
                    return;
                }

                // Check mystery cards first - CAN CLICK AT ANY TIME
                for (let card of this.mysteryCards) {
                    if (!card.revealed && card.checkHit(x, y) && this.cardsOpened < 25) {
                        this.openMysteryCard(card);
                        // After opening mystery card, reset counters and start new batch
                        this.startNewBatch();
                        return;
                    }
                }

                // Check falling cards (only if not at max picks)
                if (this.cardsPickedFromBatch < 7) {
                    for (let card of this.fallingCards) {
                        if (!card.revealed && card.checkHit(x, y)) {
                            card.reveal();
                            // Stack the values with multiplier
                            const damageValue = (card.value.damage || 0) * card.multiplier;
                            const healthValue = (card.value.health || 0) * card.multiplier;
                            this.stackedDamage += damageValue;
                            this.stackedHealth += healthValue;
                            this.cardsPickedFromBatch++;
                            
                            // If picked 7 cards, show message to select mystery card
                            if (this.cardsPickedFromBatch >= 7) {
                                this.waitingForMysteryCard = true;
                                this.batchMessage = "Select a closed card!";
                            }
                            break;
                        }
                    }
                }
            }
            
            openMysteryCard(card) {
                if (card.revealed || this.cardsOpened >= 25) return;
                
                card.reveal();
                this.cardsOpened++;
                
                // Check if all 16 good cards are opened
                if (card.isGood) {
                    this.goodCardsOpened++;
                    if (this.goodCardsOpened >= 16) {
                        this.allGoodRevealed = true;
                        // Make all remaining cards good
                        for (let c of this.mysteryCards) {
                            if (!c.revealed) {
                                c.isGood = true;
                            }
                        }
                    }
                }
                
                // Calculate applied values with multiplier
                const appliedDamage = this.stackedDamage * card.multiplier;
                const appliedHealth = this.stackedHealth * card.multiplier;
                
                // Show visual effect animation
                this.applyEffectAnimation = {
                    life: 1.0,
                    isGood: card.isGood,
                    damage: appliedDamage,
                    health: appliedHealth,
                    multiplier: card.multiplier
                };
                
                // Apply stacked values based on good/bad
                if (card.isGood) {
                    // Good: damage to boss, health to player
                    if (appliedDamage > 0) {
                        this.boss.takeDamage(appliedDamage);
                    }
                    if (appliedHealth > 0) {
                        this.playerHealth = Math.min(this.maxPlayerHealth, this.playerHealth + appliedHealth);
                        this.floatingTexts.push(new FloatingText(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, `+${Math.round(appliedHealth)}`, "#44FF44"));
                    }
                } else {
                    // Bad: damage to player, health to boss
                    if (appliedDamage > 0) {
                        this.takeDamage(appliedDamage);
                    }
                    if (appliedHealth > 0) {
                        this.boss.health = Math.min(this.boss.maxHealth, this.boss.health + appliedHealth);
                        this.floatingTexts.push(new FloatingText(this.boss.x, this.boss.y - this.boss.size, `+${Math.round(appliedHealth)}`, "#44FF44"));
                    }
                }
                
                // Reset stack
                this.stackedDamage = 0;
                this.stackedHealth = 0;
                
                // If round ends (25 cards opened), reset for next round
                if (this.cardsOpened >= 25) {
                    this.endRound();
                }
            }
            
            endRound() {
                // Reset for next round
                this.stackedDamage = 0;
                this.stackedHealth = 0;
                this.cardsOpened = 0;
                this.goodCardsOpened = 0;
                this.allGoodRevealed = false;
                this.initMysteryCards(); // New mystery cards for next round
            }

            takeDamage(amount) {
                if (amount > 0) {
                    this.playerHealth = Math.max(0, this.playerHealth - amount);
                    this.screenShake = 0.3;
                    this.floatingTexts.push(new FloatingText(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, `-${Math.round(amount)}`, "#FF4444"));
                    
                    if (this.playerHealth <= 0) {
                        this.gameState = "LOST";
                    }
                }
            }

            update(deltaTime) {
                if (this.gameState === "PLAYING") {
                    // Only spawn cards if not waiting for mystery card and batch not complete
                    if (!this.waitingForMysteryCard && this.cardsInBatch < this.batchSize) {
                        this.spawnTimer += deltaTime;
                        if (this.spawnTimer >= this.spawnInterval) {
                            this.spawnCard();
                            this.spawnTimer = 0;
                        }
                    }

                    // Boss doesn't attack during rounds
                    // this.boss.update(deltaTime);

                    // Update mystery cards
                    for (let card of this.mysteryCards) {
                        card.update(deltaTime);
                    }

                    for (let i = this.fallingCards.length - 1; i >= 0; i--) {
                        this.fallingCards[i].update(deltaTime);
                        // Remove if off screen or faded out
                        if (this.fallingCards[i].y > CANVAS_HEIGHT + 50 || this.fallingCards[i].isDead()) {
                            this.fallingCards.splice(i, 1);
                        }
                    }

                    for (let i = this.particles.length - 1; i >= 0; i--) {
                        this.particles[i].update(deltaTime);
                        if (this.particles[i].life <= 0) {
                            this.particles.splice(i, 1);
                        }
                    }

                    for (let i = this.floatingTexts.length - 1; i >= 0; i--) {
                        this.floatingTexts[i].update(deltaTime);
                        if (this.floatingTexts[i].life <= 0) {
                            this.floatingTexts.splice(i, 1);
                        }
                    }

                    if (this.screenFlash) {
                        this.screenFlash.life -= deltaTime * 1.5; // Slower fade for hyperbolic effect
                        if (this.screenFlash.intensity) {
                            this.screenFlash.intensity = Math.max(0, this.screenFlash.intensity - deltaTime * 1.2);
                        }
                        if (this.screenFlash.life <= 0) {
                            this.screenFlash = null;
                        }
                    }

                    // Update apply effect animation
                    if (this.applyEffectAnimation) {
                        this.applyEffectAnimation.life -= deltaTime * 2;
                        if (this.applyEffectAnimation.life <= 0) {
                            this.applyEffectAnimation = null;
                        }
                    }

                    if (this.screenShake > 0) {
                        this.screenShake -= deltaTime;
                        // Reduced shake intensity
                        this.shakeX = (Math.random() - 0.5) * 8 * this.screenShake;
                        this.shakeY = (Math.random() - 0.5) * 8 * this.screenShake;
                    } else {
                        this.shakeX = 0;
                        this.shakeY = 0;
                    }
                    
                    // Update light streaks
                    for (let i = this.lightStreaks.length - 1; i >= 0; i--) {
                        this.lightStreaks[i].life -= deltaTime * 2;
                        if (this.lightStreaks[i].life <= 0) {
                            this.lightStreaks.splice(i, 1);
                        }
                    }
                }
            }

            draw() {
                ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                
                ctx.save();
                ctx.translate(this.shakeX, this.shakeY);

                // Background
                const bgGradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
                bgGradient.addColorStop(0, "#1a0000");
                bgGradient.addColorStop(0.5, "#2d0000");
                bgGradient.addColorStop(1, "#000000");
                ctx.fillStyle = bgGradient;
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // Lava effects
                for (let i = 0; i < 5; i++) {
                    const x = (i / 5) * CANVAS_WIDTH;
                    const glow = Math.sin(Date.now() / 1000 + i) * 0.3 + 0.7;
                    const gradient = ctx.createRadialGradient(x, CANVAS_HEIGHT, 0, x, CANVAS_HEIGHT, 200);
                    gradient.addColorStop(0, `rgba(139, 0, 0, ${glow * 0.3})`);
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(x - 100, CANVAS_HEIGHT - 200, 200, 200);
                }

                // Reduced screen flash
                if (this.screenFlash && this.screenFlash.life > 0) {
                    const intensity = this.screenFlash.intensity || 1.0;
                    
                    // Single flash layer
                    ctx.fillStyle = this.screenFlash.color;
                    ctx.globalAlpha = 0.3 * this.screenFlash.life * intensity;
                    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    
                    // Subtle radial flash from center
                    const flashGradient = ctx.createRadialGradient(
                        CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, 0,
                        CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, Math.max(CANVAS_WIDTH, CANVAS_HEIGHT) * 0.6
                    );
                    flashGradient.addColorStop(0, this.screenFlash.color + Math.floor(150 * this.screenFlash.life * intensity).toString(16).padStart(2, '0'));
                    flashGradient.addColorStop(0.5, this.screenFlash.color + Math.floor(80 * this.screenFlash.life * intensity).toString(16).padStart(2, '0'));
                    flashGradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = flashGradient;
                    ctx.globalAlpha = 1.0;
                    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    ctx.globalAlpha = 1.0;
                }

                // Draw collected values in center (while collecting)
                if (this.gameState === "PLAYING" && (this.stackedDamage > 0 || this.stackedHealth > 0)) {
                    this.drawCollectedValues();
                }
                
                // Draw batch message in middle area
                if (this.gameState === "PLAYING" && this.batchMessage) {
                    this.drawBatchMessage();
                }

                // Draw apply effect animation
                if (this.applyEffectAnimation && this.applyEffectAnimation.life > 0) {
                    this.drawApplyEffect();
                }

                if (this.gameState === "START") {
                    this.drawStartScreen();
                } else if (this.gameState === "PLAYING" || this.gameState === "WON" || this.gameState === "LOST") {
                    this.boss.draw();

                    // Draw mystery cards
                    for (let card of this.mysteryCards) {
                        card.draw();
                    }

                    // Draw falling cards
                    for (let card of this.fallingCards) {
                        card.draw();
                    }

                    for (let particle of this.particles) {
                        particle.draw();
                    }
                    
                    // Draw HYPERBOLIC light streaks
                    for (let streak of this.lightStreaks) {
                        ctx.save();
                        ctx.translate(streak.x, streak.y);
                        ctx.rotate(streak.angle);
                        const streakGradient = ctx.createLinearGradient(0, 0, streak.length, 0);
                        streakGradient.addColorStop(0, streak.color + Math.floor(255 * streak.life).toString(16).padStart(2, '0'));
                        streakGradient.addColorStop(0.5, streak.color + Math.floor(180 * streak.life).toString(16).padStart(2, '0'));
                        streakGradient.addColorStop(1, 'transparent');
                        ctx.strokeStyle = streakGradient;
                        ctx.lineWidth = 4 + streak.life * 6;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = streak.color;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(streak.length, 0);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                        ctx.restore();
                    }

                    for (let text of this.floatingTexts) {
                        text.draw();
                    }

                    this.drawUI();

                    if (this.gameState === "WON") {
                        this.drawWinScreen();
                    } else if (this.gameState === "LOST") {
                        this.drawLoseScreen();
                    }
                }

                ctx.restore();
            }

            drawStartScreen() {
                ctx.fillStyle = "rgba(0, 0, 0, 0.85)";
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                ctx.font = "bold 48px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillStyle = "#FF4444";
                ctx.strokeStyle = "#000000";
                ctx.lineWidth = 4;
                ctx.strokeText("DEMON CARDS", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 100);
                ctx.fillText("DEMON CARDS", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 100);

                ctx.font = "24px Arial";
                ctx.fillStyle = "#FFFFFF";
                ctx.lineWidth = 2;
                ctx.strokeText("Click cards as they fall to reveal their power", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 20);
                ctx.fillText("Click cards as they fall to reveal their power", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 20);
                ctx.strokeText("Defeat the Shadow Demon!", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
                ctx.fillText("Defeat the Shadow Demon!", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
                
                ctx.font = "bold 28px Arial";
                ctx.fillStyle = "#FFD700";
                ctx.strokeText("Click to start", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 80);
                ctx.fillText("Click to start", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 80);
            }

            drawBatchMessage() {
                // Beautiful message in middle area (yellow space)
                const centerX = CANVAS_WIDTH / 2;
                const centerY = 550; // Moved 10% lower (500 * 1.10)
                const boxWidth = 350;
                const boxHeight = 100;
                
                // Animated pulsing glow effect
                const pulse = Math.sin(Date.now() / 300) * 0.2 + 0.8;
                
                // Outer glow rings
                for (let i = 0; i < 3; i++) {
                    const glowSize = boxWidth * (1 + i * 0.3) * pulse;
                    const glowAlpha = (0.3 - i * 0.1) * pulse;
                    const glowGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, glowSize);
                    glowGradient.addColorStop(0, `rgba(255, 215, 0, ${glowAlpha})`);
                    glowGradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, glowSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Main box with gradient
                const boxGradient = ctx.createLinearGradient(
                    centerX - boxWidth / 2, centerY - boxHeight / 2,
                    centerX + boxWidth / 2, centerY + boxHeight / 2
                );
                boxGradient.addColorStop(0, "rgba(255, 215, 0, 0.95)");
                boxGradient.addColorStop(0.5, "rgba(255, 200, 0, 0.9)");
                boxGradient.addColorStop(1, "rgba(255, 180, 0, 0.95)");
                ctx.fillStyle = boxGradient;
                ctx.fillRect(centerX - boxWidth / 2, centerY - boxHeight / 2, boxWidth, boxHeight);
                
                // Shine effect
                const shineGradient = ctx.createLinearGradient(
                    centerX - boxWidth / 2, centerY - boxHeight / 2,
                    centerX - boxWidth / 2, centerY
                );
                shineGradient.addColorStop(0, "rgba(255, 255, 255, 0.4)");
                shineGradient.addColorStop(1, "transparent");
                ctx.fillStyle = shineGradient;
                ctx.fillRect(centerX - boxWidth / 2, centerY - boxHeight / 2, boxWidth, boxHeight / 2);
                
                // Multiple borders for depth
                ctx.strokeStyle = "#FFD700";
                ctx.lineWidth = 5;
                ctx.strokeRect(centerX - boxWidth / 2, centerY - boxHeight / 2, boxWidth, boxHeight);
                ctx.strokeStyle = "#FFFFFF";
                ctx.lineWidth = 2;
                ctx.strokeRect(centerX - boxWidth / 2 + 3, centerY - boxHeight / 2 + 3, boxWidth - 6, boxHeight - 6);
                ctx.strokeStyle = "#FFA500";
                ctx.lineWidth = 1;
                ctx.strokeRect(centerX - boxWidth / 2 + 5, centerY - boxHeight / 2 + 5, boxWidth - 10, boxHeight - 10);
                
                // Message text with multiple effects
                ctx.font = "bold 32px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                
                // Text shadow/glow
                ctx.shadowBlur = 10;
                ctx.shadowColor = "rgba(0, 0, 0, 0.8)";
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // Outer stroke
                ctx.strokeStyle = "#000000";
                ctx.lineWidth = 6;
                ctx.strokeText(this.batchMessage, centerX, centerY);
                
                // Inner stroke
                ctx.strokeStyle = "#FFFFFF";
                ctx.lineWidth = 2;
                ctx.strokeText(this.batchMessage, centerX, centerY);
                
                // Main text with gradient
                const textGradient = ctx.createLinearGradient(centerX - 100, centerY - 20, centerX + 100, centerY + 20);
                textGradient.addColorStop(0, "#FFFFFF");
                textGradient.addColorStop(0.5, "#FFD700");
                textGradient.addColorStop(1, "#FFFFFF");
                ctx.fillStyle = textGradient;
                ctx.fillText(this.batchMessage, centerX, centerY);
                
                ctx.shadowBlur = 0; // Reset shadow
            }

            drawCollectedValues() {
                // Nice visual display - positioned clearly below boss, above yellow message box
                const centerX = CANVAS_WIDTH / 2;
                const centerY = 441; // Moved 5% lower (420 * 1.05)
                const boxWidth = 300; // Slightly wider for better visibility
                const boxHeight = 100; // Taller for better visibility
                
                // Background with glow
                const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, boxWidth);
                bgGradient.addColorStop(0, "rgba(0, 0, 0, 0.9)");
                bgGradient.addColorStop(1, "rgba(0, 0, 0, 0.7)");
                ctx.fillStyle = bgGradient;
                ctx.fillRect(centerX - boxWidth / 2, centerY - boxHeight / 2, boxWidth, boxHeight);
                
                // Border
                ctx.strokeStyle = "#FFD700";
                ctx.lineWidth = 3;
                ctx.strokeRect(centerX - boxWidth / 2, centerY - boxHeight / 2, boxWidth, boxHeight);
                
                // Title
                ctx.font = "bold 18px Arial";
                ctx.textAlign = "center";
                ctx.fillStyle = "#FFD700";
                ctx.fillText("COLLECTED", centerX, centerY - 40);
                
                // Damage
                if (this.stackedDamage > 0) {
                    ctx.font = "bold 32px Arial";
                    ctx.fillStyle = "#FF4444";
                    ctx.fillText(`‚öîÔ∏è ${Math.round(this.stackedDamage)}`, centerX - 80, centerY + 10);
                }
                
                // Health
                if (this.stackedHealth > 0) {
                    ctx.font = "bold 32px Arial";
                    ctx.fillStyle = "#44FF44";
                    ctx.fillText(`üíö ${Math.round(this.stackedHealth)}`, centerX + 80, centerY + 10);
                }
            }

            drawApplyEffect() {
                const anim = this.applyEffectAnimation;
                if (!anim) return;
                
                const centerX = CANVAS_WIDTH / 2;
                const centerY = CANVAS_HEIGHT / 2;
                const scale = 1 + (1 - anim.life) * 0.5;
                const alpha = anim.life;
                
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.scale(scale, scale);
                ctx.globalAlpha = alpha;
                
                // Background flash
                const color = anim.isGood ? "#44FF44" : "#FF4444";
                const flashGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 200);
                flashGradient.addColorStop(0, color + "80");
                flashGradient.addColorStop(1, 'transparent');
                ctx.fillStyle = flashGradient;
                ctx.beginPath();
                ctx.arc(0, 0, 200, 0, Math.PI * 2);
                ctx.fill();
                
                // Box
                const boxWidth = 350;
                const boxHeight = 150;
                ctx.fillStyle = "rgba(0, 0, 0, 0.9)";
                ctx.fillRect(-boxWidth / 2, -boxHeight / 2, boxWidth, boxHeight);
                ctx.strokeStyle = color;
                ctx.lineWidth = 4;
                ctx.strokeRect(-boxWidth / 2, -boxHeight / 2, boxWidth, boxHeight);
                
                // Title
                ctx.font = "bold 24px Arial";
                ctx.textAlign = "center";
                ctx.fillStyle = color;
                ctx.fillText(anim.isGood ? "GOOD!" : "BAD!", 0, -50);
                
                // Multiplier
                ctx.font = "bold 36px Arial";
                ctx.fillStyle = "#FFD700";
                ctx.fillText(`x${anim.multiplier}`, 0, -10);
                
                // Applied values
                ctx.font = "bold 28px Arial";
                if (anim.damage > 0) {
                    ctx.fillStyle = "#FF4444";
                    ctx.fillText(`‚öîÔ∏è ${Math.round(anim.damage)}`, -100, 40);
                }
                if (anim.health > 0) {
                    ctx.fillStyle = "#44FF44";
                    ctx.fillText(`üíö ${Math.round(anim.health)}`, 100, 40);
                }
                
                ctx.restore();
            }

            drawUI() {
                const barWidth = 200;
                const barHeight = 25;
                const barX = 20;
                const barY = CANVAS_HEIGHT - 60; // Positioned at bottom

                ctx.fillStyle = "#333";
                ctx.fillRect(barX, barY, barWidth, barHeight);

                const healthPercent = this.playerHealth / this.maxPlayerHealth;
                const healthGradient = ctx.createLinearGradient(barX, barY, barX + barWidth, barY);
                healthGradient.addColorStop(0, "#00FF00");
                healthGradient.addColorStop(healthPercent, "#44FF44");
                healthGradient.addColorStop(healthPercent, "#333");
                healthGradient.addColorStop(1, "#333");
                ctx.fillStyle = healthGradient;
                ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);

                ctx.strokeStyle = "#FFF";
                ctx.lineWidth = 2;
                ctx.strokeRect(barX, barY, barWidth, barHeight);

                ctx.font = "bold 18px Arial";
                ctx.textAlign = "left";
                ctx.fillStyle = "#FFF";
                ctx.fillText(`HP: ${Math.ceil(this.playerHealth)}/${this.maxPlayerHealth}`, barX, barY - 5);

                // Counters - positioned above player health bar
                ctx.font = "bold 18px Arial";
                ctx.textAlign = "center";
                ctx.fillStyle = "#FFD700";
                const remainingCards = this.batchSize - this.cardsInBatch;
                ctx.fillText(`Falling: ${remainingCards} left | Picked: ${this.cardsPickedFromBatch}/7 | Closed: ${this.cardsOpened}/25`, CANVAS_WIDTH / 2, CANVAS_HEIGHT - 90);
                
                if (this.allGoodRevealed) {
                    ctx.fillStyle = "#44FF44";
                    ctx.font = "bold 16px Arial";
                    ctx.fillText("ALL GOOD CARDS REVEALED!", CANVAS_WIDTH / 2, CANVAS_HEIGHT - 110);
                }
            }

            drawWinScreen() {
                ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                ctx.font = "bold 48px Arial";
                ctx.textAlign = "center";
                ctx.fillStyle = "#FFD700";
                ctx.fillText("VICTORY!", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 50);
                ctx.font = "24px Arial";
                ctx.fillStyle = "#FFF";
                ctx.fillText("You defeated the Shadow Demon!", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
                ctx.fillText("Click to play again", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 60);
            }

            drawLoseScreen() {
                ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                ctx.font = "bold 48px Arial";
                ctx.textAlign = "center";
                ctx.fillStyle = "#FF4444";
                ctx.fillText("DEFEATED", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 50);
                ctx.font = "24px Arial";
                ctx.fillStyle = "#FFF";
                ctx.fillText("The Shadow Demon has consumed you...", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
                ctx.fillText("Click to try again", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 60);
            }
        }

        // Initialize and start game
        const game = new Game();
        let lastTime = performance.now();

        function gameLoop() {
            const now = performance.now();
            const deltaTime = Math.min((now - lastTime) / 1000, 0.1);
            lastTime = now;

            game.update(deltaTime);
            game.draw();
            requestAnimationFrame(gameLoop);
        }

        function getCanvasPos(event) {
            const rect = canvas.getBoundingClientRect();
            const clientX = event.clientX || (event.changedTouches && event.changedTouches[0].clientX);
            const clientY = event.clientY || (event.changedTouches && event.changedTouches[0].clientY);
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        function onClick(event) {
            if (event.target.tagName === 'A' || event.target.tagName === 'BUTTON') {
                return;
            }
            const pos = getCanvasPos(event);
            game.handleClick(pos.x, pos.y);
        }

        function onTouchStart(event) {
            event.preventDefault();
            const pos = getCanvasPos(event);
            game.handleClick(pos.x, pos.y);
        }

        canvas.addEventListener('click', onClick);
        canvas.addEventListener('touchstart', onTouchStart);

        // Start game loop
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
